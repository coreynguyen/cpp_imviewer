// generated by Fast Light User Interface Designer (fluid) version 1.0305

#include "../include/window.h"
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1
#define DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1 19
#endif
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif
// >>>>>>>>>>>    Standard Libraries       <<<<<<<<<<<<
// Windows OS Libraries
// >>>>>>>>>>>    3rd Party Libraries      <<<<<<<<<<<<
#if !defined(FUCKSQL)
#endif
// >>>>>>>>>>>     Personal Libraries      <<<<<<<<<<<<
// >>>>>>>>>>>     GLOBAL VARIABLES       <<<<<<<<<<<<
signed int box_index = -1;
bool box_draw = false;
int boxorg[2] = {0, 0 };
int imgmin_limit_default = 10;
int imgmin_limit = 10;
int imgmax_limit = 32766;
static std::vector<unsigned char> r, g, b;
std::vector<std::wstring> filesW;
std::string imgm5d = "3B5D3C7D207E37DCEEEDD301E35E2E58";
std::wstring root_path = L""; // holds the root path of the last image opened
std::wstring work_path = L""; // for managing the folder
/**
 Stores the Windows ID in order to Access the Title Bar
*/
static HWND xid = nullptr;
int sel_file = -1;
unsigned int num_files = 0;
Fl_Text_Buffer *textbuf;
bool debug = false;
static bool USE_DARK_MODE = false;
float imgzoom = 1.0f;
std::vector<std::string> filelist(10, "");
database* settings = nullptr;
Fl_Image* imgbuf = nullptr;
Fl_Image* imgtmp = nullptr;
int keycombo[2] = {0, 0 };
int imgorg[2] = {0, 0 };
int imgpos[2] = {0, 0 };
std::vector<std::string> global_tags;
const unsigned int num_img_types = 6;
const std::wstring knownTypes[num_img_types] = {L".jpg", L".jpeg", L".bmp", L".png", L".txt" L".csv"};
// FLTK Headers
/**
 0 - no action
 1 - lock zoom
 2 - shrink to fit
 3 - enlarge to fit
*/
unsigned char imgfit = 0;
/**
  0 not set
  1 save text
  2 are there txt changes to save
  3 save csv
  4 are there csv changes to save
*/
unsigned char write_txt = 5;
/**
  0 not set
  1 regions visible
  2 editor visible
  3 tags visible
*/
unsigned char visiblity = 7;
static int edt_font_size = 12;
Fl_Cursor mousecur = Fl_Cursor::FL_CURSOR_DEFAULT;
// >>>>>>>>>>>     RESOURCES (IMAGES)       <<<<<<<<<<<<
enum Fl_Wrap {WRAP_NONE, WRAP_AT_COLUMN, WRAP_AT_PIXE, WRAP_AT_BOUNDS};
/**
 MENU EXIT ICON
*/
const unsigned char image_exit[] = {0,0,0,0,0,0,0,18,0,0,0,68,0,0,0,55,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,60,0,0,0,60,0,0,0,12,0,0,0,0,0,0,0,18,73,7,11, 201,206,23,31,254,201,23,31,253,76,7,11,168,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,18,62,7,9,178,200,23,29,254,205,23,31,254,81,10,12,184,0,0,0,12,0, 0,0,78,189,21,29,254,236,28,37,255,236,28,37,255,221,25,34,255,76,9,10,171,0, 0,0,12,0,0,0,0,0,0,0,0,0,0,0,18,61,7,8,183,217,25,33,255,236,28,37,255,236,28, 37,255,207,23,31,254,0,0,0,60,0,0,0,75,183,21,28,254,236,28,37,255,236,28,37, 255,236,28,37,255,220,25,33,255,73,7,11,167,0,0,0,12,0,0,0,18,61,7,8,184,217,25, 32,255,236,28,37,255,236,28,37,255,236,28,37,255,194,22,29,253,0,0,0,58,0,0,0, 15,49,5,6,192,214,24,32,255,236,28,37,255,236,28,37,255,236,28,37,255,220,26, 33,255,71,7,10,175,59,7,8,188,217,25,33,255,236,28,37,255,236,28,37,255,236,28, 37,255,216,25,33,255,58,6,9,172,0,0,0,9,0,0,0,0,0,0,0,26,48,5,6,195,212,23,31, 255,236,28,37,255,236,28,37,255,236,28,37,255,220,25,33,255,217,25,34,255,236, 28,37,255,236,28,37,255,236,28,37,255,215,24,33,255,59,6,8,178,0,0,0,18,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,24,46,5,7,192,211,24,32,255,236,28,37,255,236,28,37, 255,236,28,37,255,236,28,37,255,236,28,37,255,236,28,37,255,216,25,33,255,59,6, 8,178,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,45,5,6,197, 212,23,33,255,236,28,37,255,236,28,37,255,236,28,37,255,236,28,37,255,216,24,33, 255,56,5,8,183,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 21,59,7,9,193,219,25,33,255,236,28,37,255,236,28,37,255,236,28,37,255,236,28, 37,255,220,25,33,255,71,7,10,175,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,21,64,7,9,187,218,25,34,255,236,28,37,255,236,28,37,255,236,28,37, 255,236,28,37,255,236,28,37,255,236,28,37,255,220,25,33,255,75,8,10,169,0,0,0, 12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,64,7,9,187,218,25,33,255,236,28,37,255,236, 28,37,255,236,28,37,255,215,24,32,255,211,24,32,255,236,28,37,255,236,28,37, 255,236,28,37,255,220,25,33,255,75,8,10,169,0,0,0,12,0,0,0,0,0,0,0,12,62,7,10, 184,219,25,33,255,236,28,37,255,236,28,37,255,236,28,37,255,214,24,32,255,53,5, 7,183,44,5,6,196,211,24,32,255,236,28,37,255,236,28,37,255,236,28,37,255,221, 25,33,255,76,8,11,165,0,0,0,6,0,0,0,70,184,21,28,253,236,28,37,255,236,28,37, 255,236,28,37,255,213,24,32,255,54,6,7,173,0,0,0,18,0,0,0,24,45,5,7,191,211,24, 32,255,236,28,37,255,236,28,37,255,236,28,37,255,194,22,29,252,0,0,0,48,0,0,0, 82,188,21,28,254,236,28,37,255,236,28,37,255,213,24,32,255,54,6,7,173,0,0,0,15, 0,0,0,0,0,0,0,0,0,0,0,24,44,4,7,191,210,24,32,255,236,28,37,255,236,28,37,255, 188,22,28,253,0,0,0,53,0,0,0,24,55,6,7,204,185,21,28,254,184,21,28,253,54,6,7, 170,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,44,4,7,185,176,20,27,253, 179,20,26,254,67,7,9,187,0,0,0,12,0,0,0,0,0,0,0,21,0,0,0,79,0,0,0,68,0,0,0,9,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,70,0,0,0,70,0,0, 0,15,0,0,0,0};
Fl_Image *icon_exit() { static Fl_Image *image = new Fl_RGB_Image(image_exit, 16, 16, 4, 0); return image; };
/**
 MENU ABOUT ICON
*/
const unsigned char image_about[] = {0,0,0,0,0,0,0,58,0,0,0,172,0,0,0,205,0,0,0,209,0,0,0,209,0,0,0,209,0,0,0, 209,0,0,0,209,0,0,0,209,0,0,0,209,0,0,0,209,0,0,0,202,0,0,0,136,0,0,0,31,0,0,0, 0,0,0,0,56,51,31,18,249,206,126,76,255,244,149,89,255,245,148,90,255,245,148, 90,255,245,148,90,255,245,148,90,255,245,148,90,255,245,148,90,255,245,148,90, 255,245,148,90,255,244,149,89,255,206,124,76,255,55,33,20,226,0,0,0,29,0,0,0, 157,202,123,74,255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255, 245,148,90,255,140,85,51,208,99,60,36,190,232,141,85,255,247,150,91,255,247,150, 91,255,247,150,91,255,247,150,91,255,200,120,73,255,0,0,0,94,0,0,0,171,239,144, 87,255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,242,147,89, 255,17,9,5,194,0,0,0,191,189,115,69,255,247,150,91,255,247,150,91,255,247,150, 91,255,247,150,91,255,238,144,87,255,0,0,0,108,0,0,0,171,239,145,88,255,247, 150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,245,148,91,255,180,110, 67,255,149,91,55,255,244,149,89,255,247,150,91,255,247,150,91,255,247,150,91, 255,247,150,91,255,239,144,87,255,0,0,0,109,0,0,0,171,239,145,88,255,247,150,91, 255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255, 247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,247, 150,91,255,239,144,87,255,0,0,0,109,0,0,0,171,239,145,88,255,247,150,91,255,247, 150,91,255,247,150,91,255,247,150,91,255,240,145,89,255,103,63,37,170,109,66,40, 159,194,118,71,255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255, 239,144,87,255,0,0,0,109,0,0,0,171,239,145,88,255,247,150,91,255,247,150,91,255, 247,150,91,255,247,150,91,255,238,144,87,255,4,2,0,125,0,0,0,106,175,106,64,255, 247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,239,144,87,255,0,0, 0,109,0,0,0,171,239,145,88,255,247,150,91,255,247,150,91,255,247,150,91,255, 247,150,91,255,238,144,87,255,4,2,0,125,0,0,0,106,175,106,64,255,247,150,91,255, 247,150,91,255,247,150,91,255,247,150,91,255,239,144,87,255,0,0,0,109,0,0,0,171, 239,145,88,255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,238, 144,87,255,4,2,0,125,0,0,0,106,175,106,64,255,247,150,91,255,247,150,91,255,247, 150,91,255,247,150,91,255,239,144,87,255,0,0,0,109,0,0,0,171,239,145,88,255,247, 150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,238,144,87,255,4,2,0, 125,0,0,0,106,175,106,64,255,247,150,91,255,247,150,91,255,247,150,91,255,247, 150,91,255,239,144,87,255,0,0,0,108,0,0,0,171,239,145,88,255,247,150,91,255,247, 150,91,255,247,150,91,255,247,150,91,255,238,144,87,255,4,2,0,132,0,0,0,115,175, 106,64,255,247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,235,143, 86,255,0,0,0,90,0,0,0,171,239,145,88,255,247,150,91,255,247,150,91,255,247,150, 91,255,247,150,91,255,241,146,88,255,92,56,34,254,91,55,33,253,201,122,74,255, 247,150,91,255,247,150,91,255,247,150,91,255,247,150,91,255,182,110,67,240,0,0, 0,22,0,0,0,171,239,145,88,255,245,148,90,255,196,118,72,244,196,118,71,235, 196,118,71,235,196,118,71,235,196,118,71,235,196,118,71,235,196,118,71,235,196, 118,71,235,196,118,71,235,197,119,72,232,190,116,70,189,120,71,43,36,0,0,0,0,0, 0,0,168,240,145,88,254,148,90,53,204,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,200, 121,73,149,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
Fl_Image *icon_about() { static Fl_Image *image = new Fl_RGB_Image(image_about, 16, 16, 4, 0); return image; };
/**
 MENU PLACE HOLDER ICON
*/
const unsigned char image_dummy[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0};
Fl_Image *icon_dummy() { static Fl_Image *image = new Fl_RGB_Image(image_dummy, 16, 16, 4, 0); return image; };
/**
 MENU OPEN ICON
*/
static const unsigned char image_open[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,141,90,16,107,226,148,27,255,228,151,27,255,228,151,27,255,228,151,27, 255,214,140,26,254,103,67,9,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,146,96,18,188,192,126,23,250,234,154,29,255,234,154,29,255, 234,154,29,255,234,154,29,255,234,154,29,255,184,121,22,250,148,97,17,218,148, 97,17,218,148,97,17,218,148,97,17,218,149,98,18,211,169,119,17,15,0,0,0,0,0,0, 0,0,225,148,28,255,240,184,87,255,246,210,139,255,246,210,139,255,246,210,139, 255,246,210,139,255,246,210,139,255,246,210,139,255,246,210,139,255,246,210,139, 255,245,209,138,255,234,164,51,255,234,154,29,255,134,86,14,74,0,0,0,0,0,0,0,0, 225,148,28,255,245,211,144,255,59,57,46,139,38,38,28,54,38,38,28,54,38,38,28,54, 38,38,28,54,38,38,28,54,38,38,28,54,38,38,28,54,38,38,28,54,59,42,15,122,228, 150,28,255,134,86,14,74,0,0,0,0,0,0,0,0,225,148,28,255,243,210,142,255,5,5,5,49, 85,85,28,9,71,71,28,18,71,71,28,18,71,71,28,18,71,71,28,18,71,71,28,18,71,71, 28,18,71,71,28,18,42,42,17,30,219,146,32,255,129,89,17,89,81,69,11,22,102,76,0, 10,225,148,28,255,243,210,142,255,79,68,18,97,235,196,34,255,246,204,36,255, 246,204,36,255,246,204,36,255,246,204,36,255,246,204,36,255,246,204,36,255,246, 204,36,255,246,204,36,255,246,204,37,255,247,205,36,255,248,206,36,255,219,181, 31,252,225,148,28,255,243,210,142,255,148,125,25,232,248,206,36,255,248,206,36, 255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255, 248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,166, 137,23,223,225,148,28,255,244,209,135,255,232,194,35,255,248,206,36,255,248,206, 36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36, 255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,245,203,35,255, 150,125,20,63,225,148,28,255,242,198,73,255,248,206,36,255,248,206,36,255,248, 206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206, 36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,184,153,26, 240,0,0,0,0,225,148,28,255,244,197,40,255,248,206,36,255,248,206,36,255,248,206, 36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36, 255,248,206,36,255,248,206,36,255,248,206,36,255,246,204,35,255,144,119,20,113, 0,0,0,0,228,161,37,255,248,205,36,255,248,206,36,255,248,206,36,255,248,206, 36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36,255,248,206,36, 255,248,206,36,255,248,206,36,255,248,206,36,255,206,171,29,250,0,0,0,0,0,0,0,0, 215,170,34,250,242,202,34,255,242,202,34,255,242,202,34,255,242,202,34,255,242, 202,34,255,242,202,34,255,242,202,34,255,242,202,34,255,242,202,34,255,242,202, 34,255,242,202,34,255,239,199,34,255,147,122,21,142,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
Fl_Image *icon_open() { static Fl_Image *image = new Fl_RGB_Image(image_open, 16, 16, 4, 0); return image; };
/**
 CHECK ICON
*/
static const unsigned char image_checked[] = {0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1, 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0, 0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,254,0, 0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,255,0,0,0,53,0,0,0,53,0,0,0,53,0,0,0,53,0, 0,0,53,0,0,0,53,0,0,0,53,0,0,0,53,0,0,0,52,0,0,0,52,0,0,0,53,0,0,0,255,0,0,0, 1,0,0,0,1,0,0,0,1,0,0,0,255,0,0,0,53,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1, 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,254,0,0,0,255,0,0,0,254,0,0,0,1,0,0,0,1, 0,0,0,255,0,0,0,53,0,0,0,1,0,0,0,1,0,0,0,255,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1, 0,0,0,255,0,0,0,254,0,0,0,254,0,0,0,255,0,0,0,255,0,0,0,1,0,0,0,0,0,0,0,255,0, 0,0,51,0,0,0,0,0,0,0,255,0,0,0,254,0,0,0,254,0,0,0,1,0,0,0,1,0,0,0,254,0,0,0, 254,0,0,0,254,0,0,0,254,0,0,0,108,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,255,0,0,0,51,0, 0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254, 0,0,0,254,0,0,0,143,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,51,0,0,0, 99,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0, 143,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,53,0,0,0,1,0,0,0, 120,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,144,0,0,0,1,0,0,0,0, 0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,53,0,0,0,1,0,0,0,1,0,0,0, 129,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,144,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,255,0, 0,0,86,0,0,0,0,0,0,0,2,0,0,0,255,0,0,0,55,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,120,0, 0,0,254,0,0,0,144,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,86,0,0,0,0, 0,0,0,2,0,0,0,255,0,0,0,55,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,1,0,0,0,99,0,0,0,1,0, 0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,2,0,0,0,255,0, 0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254, 0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,2,0,0,0,254,0, 0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254, 0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,1,0,0,0,1,0,0, 0,87,0,0,0,87,0,0,0,87,0,0,0,87,0,0,0,86,0,0,0,86,0,0,0,86,0,0,0,86,0,0,0,86, 0,0,0,86,0,0,0,86,0,0,0,86,0,0,0,86,0,0,0,0};
Fl_Image *icon_checked() { static Fl_Image *image = new Fl_RGB_Image(image_checked, 16, 16, 4, 0); return image; };
/**
 UNCHECK ICON
*/
static const unsigned char image_unchecked[] = {0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1, 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0, 0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,254,0, 0,0,255,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,255,0,0,0,52,0,0,0,52,0,0,0,52,0,0,0,52, 0,0,0,52,0,0,0,52,0,0,0,52,0,0,0,52,0,0,0,51,0,0,0,51,0,0,0,52,0,0,0,255,0,0, 0,86,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,52,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0, 1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,1, 0,0,0,255,0,0,0,52,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,51,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,51,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,86,0, 0,0,0,0,0,0,0,0,0,0,255,0,0,0,51,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,1,0,0,0, 255,0,0,0,52,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0, 0,0,0,0,0,0,0,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,1,0,0,0,255,0,0,0,52,0,0,0,1,0, 0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0, 255,0,0,0,86,0,0,0,0,0,0,0,2,0,0,0,255,0,0,0,53,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1, 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,86,0,0,0,0,0, 0,0,2,0,0,0,255,0,0,0,53,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,1,0,0, 0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,2,0,0,0,255,0,0, 0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0, 0,0,254,0,0,0,254,0,0,0,254,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,2,0,0,0,254,0,0, 0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0,0,0,254,0, 0,0,254,0,0,0,254,0,0,0,254,0,0,0,255,0,0,0,86,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0, 88,0,0,0,88,0,0,0,88,0,0,0,88,0,0,0,86,0,0,0,86,0,0,0,86,0,0,0,86,0,0,0,86,0,0, 0,86,0,0,0,87,0,0,0,87,0,0,0,86,0,0,0,0};
Fl_Image *icon_unchecked() { static Fl_Image *image = new Fl_RGB_Image(image_unchecked, 16, 16, 4, 0); return image; };
// >>>>>>>>>>> INITIALIZING FUNCTIONS <<<<<<<<<<<<

static void rebuild_mnu_recents() {
  if (settings == nullptr) {return;}
  unsigned int num_recents = settings->recents.size();
  if (num_recents == 0) {return;}

  for (unsigned int i = 0; i < 10; i++) {
      filelist.at(i) = "&" + to_string(i + 1) + ".) ";
      if (i < num_recents) {
          filelist.at(i) += getFilename::FromPath(settings->recents.at(i));
          }
      //std::cout << "File" << i << ": \t" << filelist.at(i) << std::endl;

      switch (i) {
          case 0: {itm_recents0->label(filelist.at(i).c_str()); break;}
          case 1: {itm_recents1->label(filelist.at(i).c_str()); break;}
          case 2: {itm_recents2->label(filelist.at(i).c_str()); break;}
          case 3: {itm_recents3->label(filelist.at(i).c_str()); break;}
          case 4: {itm_recents4->label(filelist.at(i).c_str()); break;}
          case 5: {itm_recents5->label(filelist.at(i).c_str()); break;}
          case 6: {itm_recents6->label(filelist.at(i).c_str()); break;}
          case 7: {itm_recents7->label(filelist.at(i).c_str()); break;}
          case 8: {itm_recents8->label(filelist.at(i).c_str()); break;}
          case 9: {itm_recents9->label(filelist.at(i).c_str()); break;}
          }
      }
}

static void init_database() {
  // Creates the Database Object
  if (settings == nullptr) {
      settings = new database;
      }

  // opens or auto creates a new SQL database next to the EXE
  settings->open("imvdb.db");

  // read the recents files
  rebuild_mnu_recents();


  //    settings->addTag("example45", "om  a pc");
  //    settings->addImage("C:\\test\\image.png", "0000000000000000002", 512, 512);
  //    settings->modify("image", "hash", "0000000000000000000", std::vector<std::string>{"fullpath"}, std::vector<std::string>{"Corey"});
  //
  //        std::cout << settings->rows("image", "hash") << std::endl;


  //    std::vector<std::string> data = settings->fetch("image", "hash", "'0000000000000000000'", std::vector<std::string>{"fullpath"}, "T");
  //    for (unsigned int i = 0; i < data.size(); i++) {
  //        std::cout << "data: " << data.at(i) << std::endl;
  //        }
}

/**
 Toggles Light / Dark Themes
*/
void toggle_theme() {
  USE_DARK_MODE = !is_light_theme();
  //int N = 4 + FL_NUM_GRAY;
  if (USE_DARK_MODE) { // dark mode
      Fl::set_color(FL_BACKGROUND_COLOR, 50, 50, 50);
      Fl::set_color(FL_BACKGROUND2_COLOR, 120, 120, 120);
      Fl::set_color(FL_FOREGROUND_COLOR, 240, 240, 240);
      for (int i = 0; i < FL_NUM_GRAY; i++) {
          double min = 0., max = 135.;
          int d = (int)(min + i * (max - min) / (FL_NUM_GRAY - 1.));
          Fl::set_color(fl_gray_ramp(i), d, d, d);
          }
      Fl::reload_scheme();
      Fl::set_color(FL_SELECTION_COLOR, 200, 200, 200);
      }
  else {
      // restore default colors
      Fl::set_color(FL_BACKGROUND_COLOR, r[0], g[0], b[0]);
      Fl::set_color(FL_BACKGROUND2_COLOR, r[1], g[1], b[1]);
      Fl::set_color(FL_FOREGROUND_COLOR, r[2], g[2], b[2]);
      for (int i = 0; i < FL_NUM_GRAY; i++) {
          Fl::set_color(fl_gray_ramp(i), r[4 + i], g[4 + i], b[4 + i]);
          }
      Fl::reload_scheme();
      Fl::set_color(FL_SELECTION_COLOR, r[3], g[3], b[3]);
      }

  if (xid != nullptr) {
      //DWMNCRENDERINGPOLICY ncrp = USE_DARK_MODE ? DWMNCRP_DISABLED : DWMNCRP_ENABLED;     // Enable/disable non-client area rendering on the window.
      //bool SET_IMMERSIVE_DARK_MODE_SUCCESS = SUCCEEDED(DwmSetWindowAttribute(xid, DWMWA_USE_IMMERSIVE_DARK_MODE, &USE_DARK_MODE, 4));
      SUCCEEDED(DwmSetWindowAttribute(xid, DWMWA_USE_IMMERSIVE_DARK_MODE, &USE_DARK_MODE, 4));
      ::UpdateWindow(xid);
      }
}

/**
 Try to determine if user is using dark theme
*/
bool is_light_theme() {
  // based on https://stackoverflow.com/questions/51334674/how-to-detect-windows-10-light-dark-mode-in-win32-application

  // The value is expected to be a REG_DWORD, which is a signed 32-bit little-endian
  auto buffer = std::vector<char>(4);
  auto cbData = static_cast<DWORD>(buffer.size() * sizeof(char));
  auto res = RegGetValueW(
      HKEY_CURRENT_USER,
      L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize",
      L"AppsUseLightTheme",
      RRF_RT_REG_DWORD, // expected value type
      nullptr,
      buffer.data(),
      &cbData
      );

  if (res != ERROR_SUCCESS) {
      throw std::runtime_error("Error: error_code=" + std::to_string(res));
      }

  // convert bytes written to our buffer to an int, assuming little-endian
  auto i = int(buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0]);

  return i == 1;
}
// >>>>>>>>>>>     HELPER  FUNCTIONS      <<<<<<<<<<<<





std::string md5(const char* &message, unsigned long len, unsigned long start_pos ) {
  /*
      used to generate an identity for the image
      char test[5] = {0, 1, 2, 3, 4};
      md5((const char*)test, 5); // D05374DC381D9B52806446A71C8E79B1

  */
  unsigned char SHIFT_AMTS[16] = {7, 12, 17, 22, 5,  9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21};
  unsigned long TABLE_T[64] = { // 64 Entries, 256 Bytes
      0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE,
      0xF57C0FAF, 0x4787C62A, 0xA8304613, 0xFD469501,
      0x698098D8, 0x8B44F7AF, 0xFFFF5BB1, 0x895CD7BE,
      0x6B901122, 0xFD987193, 0xA679438E, 0x49B40821,
      0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,
      0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8,
      0x21E1CDE6, 0xC33707D6, 0xF4D50D87, 0x455A14ED,
      0xA9E3E905, 0xFCEFA3F8, 0x676F02D9, 0x8D2A4C8A,
      0xFFFA3942, 0x8771F681, 0x6D9D6122, 0xFDE5380C,
      0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,
      0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05,
      0xD9D4D039, 0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665,
      0xF4292244, 0x432AFF97, 0xAB9423A7, 0xFC93A039,
      0x655B59C3, 0x8F0CCC92, 0xFFEFF47D, 0x85845DD1,
      0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,
      0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391
      };
  unsigned long numBlocks = ((len + 8) >> 6) + 1;
  unsigned long totalen = numBlocks << 6;
  unsigned long* paddingBytes = nullptr;
  unsigned long paddingen = totalen - len;
  if (paddingen > 0) {
      paddingBytes = new unsigned long[paddingen];
      paddingBytes[0] = 0x80;
      for (unsigned long i = 1; i < paddingen; i++) {
          paddingBytes[i] = 0;
          }
      }
  unsigned long messageenBits = len << 3;
  for (unsigned char i = 0; i < 8; i++) {
      paddingBytes[paddingen - 8 + i] = messageenBits;
      messageenBits = messageenBits >> 8;
      }
  unsigned long INIT_A = 0x67452301;
  unsigned long INIT_B = 0xEFCDAB89;
  unsigned long INIT_C = 0x98BADCFE;
  unsigned long INIT_D = 0x10325476;
  unsigned long a = INIT_A;
  unsigned long b = INIT_B;
  unsigned long c = INIT_C;
  unsigned long d = INIT_D;
  unsigned long f = 0;
  unsigned long buffer[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // 16
  unsigned long index = 0;
  unsigned long originalA = INIT_A;
  unsigned long originalB = INIT_B;
  unsigned long originalC = INIT_C;
  unsigned long originalD = INIT_D;
  unsigned char div16 = 0;
  unsigned long bufferIndex = 0;
  unsigned long temp = 0;
  unsigned long temp2 = 0;
  for (unsigned long i = 0; i < numBlocks; i++) {
      index = i << 6;
      for (unsigned char j = 0; j < 64; j++) {
          buffer[j >> 2] = ((index < len ? message[start_pos + index] : paddingBytes[index - len]) << 24) | (buffer[j >> 2] >> 8);
          index += 1;
          }
      originalA = a;
      originalB = b;
      originalC = c;
      originalD = d;
      for (unsigned char j = 0; j < 64; j++) {
          div16 = j >> 4;
          f = 0;
          bufferIndex = j;
          switch (div16) {
              case 0: {
                  f = (b & c) | (~b & d);
                  break;
                  }
              case 1: {
                  f = (b & d) | (c & ~d);
                  bufferIndex = ((bufferIndex * 5) + 1) & 0x0F;
                  break;
                  }
              case 2: {
                  f = (b ^ c) ^ d;
                  bufferIndex = ((bufferIndex * 3) + 5) & 0x0F;
                  break;
                  }
              case 3: {
                  f = c ^ (b | ~d);
                  bufferIndex = (bufferIndex * 7) & 0x0F;
                  break;
                  }
              }
          temp2 = SHIFT_AMTS[(div16 << 2) | (j & 3)];
          temp = a + f + buffer[bufferIndex] + TABLE_T[j];
          temp = b + ((temp << temp2) | ((temp >> (32 - temp2)) & ((1 << temp2) - 1)));
          a = d;
          d = c;
          c = b;
          b = temp;
          }
      a += originalA;
      b += originalB;
      c += originalC;
      d += originalD;
      }
  if (paddingBytes != nullptr) {delete[] paddingBytes;}
  unsigned long result[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // 16
  unsigned char count = 0;
  unsigned long n = 0;
  for (unsigned char i = 0; i < 4; i++) {
      switch (i) {
          case 0: n = a; break;
          case 1: n = b; break;
          case 2: n = c; break;
          case 3: n = d; break;
          }
      for (unsigned char j = 0; j < 4; j++) {
          result[count++] = n & 0xFF;
          n = n >> 8;
          }
      }
  std::string md5str = "";
  for (unsigned char i = 0; i < 16; i++) {
      md5str += n2hexstr(result[i], 2);
      }
  //std::cout << "RESULT: \t" << md5str << std::endl;
  return md5str;
}

static std::vector<std::string> getDelimitedTags(std::string str, bool culltag , bool sorttags ) {
    std::vector<std::string> tags = split(str, ",");
    //std::cout << "Tags: \t" << str << std::endl;
    unsigned int num_tags = tags.size();
    if (num_tags > 0) {
        for (unsigned int i = 0; i < num_tags; i++) {
            tags.at(i) = tolower(trim(trim(tags.at(i), " "), "\t"));
            }

        if (sorttags) { std::sort(tags.begin(), tags.end()); }

        if (culltag) {
            std::vector<std::string> tmp;
            for (unsigned int i = 0; i < num_tags; i++) {
                if (std::find(tmp.begin(), tmp.end(), tags.at(i)) == tmp.end()) {
                    tmp.push_back(tags.at(i));
                    }// else {std::cout << "Duplicate: \t" << tags.at(i) << std::endl;}
                }
            return tmp;
            }

        }
    return tags;
    }

static void redraw_ui() {
  // Redraw all Widgets, FLTK doesn't properly refresh when images are loaded
  win_main->redraw();
  mnu_bar->redraw();
  tile_info->redraw();
}

bool isSelectionValid(bool checkDB ) {
  if (sel_file > -1) {
      if (filesW.size() > 0 && sel_file < (signed)filesW.size()) {
          if (checkDB) {
              if (settings != nullptr && settings->image.size() > 0 && sel_file < (signed)settings->image.size()) {
                  return true;
                  }
              return false;
              }
          return true;
          }
      }
  return false;
}

static void img_origin() {
  // Updates Origin
  imgorg[0] = Fl::event_x(); imgorg[1] = Fl::event_y();
  if (debug) {std::cout << "ORG: \t[" << imgorg[0] << ", " << imgorg[1] << "]" << std::endl;}
}

static void img_move() {
  // Calculate relative offset from the last mouse click (origin point) to the current point
  if (debug) {std::cout << "Pos: \t[" << imgpos[0] << ", " << imgpos[1] << "]" << std::endl;}
  imgpos[0] += (Fl::event_x() - imgorg[0]);
  imgpos[1] += (Fl::event_y() - imgorg[1]);

  // Origin becomes the current mouse point
  img_origin();

  // Update position of image
  shp_image->position(imgpos[0], imgpos[1] );

  // Redraw all Widgets to avoid artifacts
  redraw_ui();
}

static void img_restore() {
  //create_tag_button("");
  // Calculate center of widget area to position image
  imgpos[0] = tile_view->x() + (tile_view->w() / 2) - (shp_image->w() / 2);
  imgpos[1] = tile_view->y() + (tile_view->h() / 2) - (shp_image->h() / 2);

  // Update origin
  img_origin();

  // Update Image position (should now be in the center)
  shp_image->position(imgpos[0], imgpos[1] );
  shp_image->redraw();
  redraw_ui();
}

static void img_resize() {
  // get min / max of the image
  unsigned int img_max = imgbuf->w();
  unsigned int img_min = imgbuf->h();
  if ((unsigned int)imgbuf->h() > img_max) {
      img_max = imgbuf->h();
      img_min = imgbuf->w();
      }

  // get min / max of the canvas widget
  unsigned int wid_max = tile_view->w();
  unsigned int wid_min = tile_view->h();
  if ((unsigned int)tile_view->h() > wid_max) {
      wid_max = tile_view->h();
      wid_min = tile_view->w();
      }


  // Calculate Zoom ratio
  if ((float)imgbuf->w() / (float)imgbuf->h() > 1.0f) {
      // Image is more Horizontial
      imgzoom = (float)wid_min / (float)img_min;
      }
  else {
      // image is more Vertial
      imgzoom = (float)wid_min / (float)img_max;
      }

  // check zoom flag
  if (bit::get(imgfit, 2) == false && imgzoom < 1.0f) {imgzoom = 1.0f;} // shrink to fit
  if (bit::get(imgfit, 3) == false && imgzoom > 1.0f) {imgzoom = 1.0f;} // enlarge to fit
}

static void img_rescale() {
  // Scale Width, Height
  int rsize_w = (int)((float)imgbuf->w() * imgzoom);
  int rsize_h = (int)((float)imgbuf->h() * imgzoom);

  // Scale Image
  if (imgtmp != nullptr) {delete imgtmp; imgtmp = nullptr;}
  imgtmp = imgbuf->copy( rsize_w, rsize_h );
  size_t errMsgLen= 0;
  char* errMsg = nullptr;
  switch ( imgtmp->fail() ) {
      case Fl_Image::ERR_NO_IMAGE:
      case Fl_Image::ERR_FILE_ACCESS: {
          strerror_s(errMsg, errMsgLen, errno);
          fl_alert("%s: %s", "FLIE", std::string(errMsg).c_str()); break;


          if (errMsg != nullptr) {
              delete errMsg;
              }

          }
      case Fl_Image::ERR_FORMAT: {fl_alert("%s: couldn't decode image", "FILE"); break;}
      }

  std::string info = to_string((int)(imgzoom * 100)) + "%";
  lb_zoom->value(info.c_str());

  // Render Image
  shp_image->image( imgtmp );
  //shp_image->redraw();
}

static void img_scale() {
  // bail if zoom is locked
  if (bit::get(imgfit, 1)) {return;}

  // Default Scale Increment
  float inc = 0.05f;

  // Increment Zoom Ratio by increment amount
  float oldzoom = imgzoom;
  if (Fl::event_dy() < 0) {imgzoom += inc;} else {imgzoom -= inc;}

  // Scale Width, Height
  int rsize_w = (signed int)((float)imgbuf->w() * imgzoom);
  int rsize_h = (signed int)((float)imgbuf->h() * imgzoom);


  if (rsize_w < 1 || rsize_h < 1 || rsize_w < imgmin_limit || rsize_h < imgmin_limit || rsize_w > imgmax_limit || rsize_h > imgmax_limit) {
      imgzoom = (float)oldzoom;
      return;
      }

  /*
      I'm having issues with images crashing when resized...
      memory allocation error ??

      I'm not sure how to properly deal with this
      so I'm just going to cap the zoom
  */
  if (imgzoom < 0.1f) {
      imgzoom = 0.1f;
      }
  else if (imgzoom > 2.0f) {imgzoom = 2.0f;}



  // Calculate Pitch
  //int rsize_p = rsize_w * rsize_h;

  // Use Copy to Rescale Image
  if (imgtmp != nullptr) {delete imgtmp; imgtmp = nullptr;}
  imgtmp = imgbuf->copy( rsize_w, rsize_h );
  char* errMsg = nullptr;
  size_t errMsgLen = 0;
  // Check for Image loading errors? doesn't prevent crashing though.. so huh... whats the point?
  switch ( imgtmp->fail() ) {
      case Fl_Image::ERR_NO_IMAGE:
      case Fl_Image::ERR_FILE_ACCESS: {
          strerror_s(errMsg, errMsgLen, errno);
          fl_alert("%s: %s", "FLIE", std::string(errMsg).c_str()); break;
          if (errMsg != nullptr) {
              delete errMsg;
              }
          }
      case Fl_Image::ERR_FORMAT: {fl_alert("%s: couldn't decode image", "FILE"); break;}
      }

  // Update Status bar information
  std::string info = to_string((int)(imgzoom * 100)) + "%";
  lb_zoom->value(info.c_str());

  // Render Image
  shp_image->image( imgtmp );
  shp_image->redraw();
  redraw_ui();
}

static void tags_btn_update(Fl_Widget* o, void* userdata) {

    // Set Write Flag
    if (bit::get(write_txt, 2) == false) {
        write_txt = bit::set(write_txt, 2, true);
        }

    const char* sp = static_cast<char*>(userdata);

    std::string tags_text = textbuf->text();
    //std::cout << "TextBuffer: \t" << tags_text << std::endl;
    Fl_Light_Button* lbtn = (Fl_Light_Button*)o;

    bool state = (bool)lbtn->value();
    if (state) {
        tags_text+=", " + std::string(sp);
        }
    else {
        std::string tmp = std::string(sp);
        unsigned int x = tags_text.find(tmp);
        if (x != std::string::npos) {
            tags_text.erase(x, tmp.size());
            }
        }

    std::vector<std::string> ss = split(tags_text, ",");
    unsigned int num_split_tags = ss.size();
    for (unsigned int i = 0; i < num_split_tags; i++) {
        ss.at(i) = trim(ss.at(i), " ");
        ss.at(i) = trim(ss.at(i), "\t");
        ss.at(i) = tolower(ss.at(i));
        }
    if (num_split_tags > 0) {std::sort(ss.begin(), ss.end());}

    std::vector<std::string> descret_tags;
    for (unsigned int i = 0; i < num_split_tags; i++) {
        ss.at(i) = trim(ss.at(i), " ");
        ss.at(i) = trim(ss.at(i), "\t");
        if (ss.at(i).size() == 0) {continue;}
        ss.at(i) = tolower(ss.at(i));
        descret_tags.push_back(ss.at(i));
        }
    tags_text = "";
    num_split_tags = descret_tags.size();
    for (unsigned int i = 0; i < num_split_tags; i++) {
        tags_text += descret_tags.at(i);
        if (i + 1 < num_split_tags) {
            tags_text += ", ";
            }
        }
    textbuf->text(tags_text.c_str());
    edt_sdtags->redraw();
    }

static void create_tag_button(std::string tag_name ) {
    unsigned int tag_width = 80;
    unsigned int tag_height = 20;
    unsigned int tag_padding = 2;
    unsigned int num_tagbtns = tag_sidebar_pack->children();

    if (tag_name.size() == 0) {
        tag_name = "Button" + to_string(num_tagbtns + 1);
        }

    Fl_Light_Button* lbtn = (
        new Fl_Light_Button(
            tag_sidebar_pack->x(),
            tag_sidebar_pack->y() + (num_tagbtns * (tag_height + tag_padding)),
            tag_width, tag_height,
            tag_name.c_str()
            )
        );
    lbtn->box(FL_NO_BOX);
    lbtn->labelfont(5);
    lbtn->copy_label(tag_name.c_str());
    lbtn->callback((Fl_Callback*)tags_btn_update, (void*)lbtn->label());
    tag_sidebar_pack->add(lbtn);
    }

static void update_tag_buttons() {
    unsigned int num_tag_btns = tag_sidebar_pack->children();
    if (num_tag_btns > 0) {
        Fl_Widget* lbtn;
        std::string str;
        for (unsigned int i = num_tag_btns; i --> 0; ) {
            lbtn = tag_sidebar_pack->child(i); // Returns Pointer from Object
            if (lbtn->label()) {
                str = lbtn->label();
                if (std::find(global_tags.begin(), global_tags.end(), str) == global_tags.end()) {
                    global_tags.push_back(str);
                    }

                }
            tag_sidebar_pack->remove(i); // Remove Widget
            //settings->remove(i); // this is for removing a regiun huh
            delete lbtn; // Delete Widget Object
            }
        }
    num_tag_btns = global_tags.size();
    if (num_tag_btns > 0) {
        std::sort(global_tags.begin(), global_tags.end());
        }
    for (unsigned int i = 0; i < num_tag_btns; i++) {
        create_tag_button(global_tags.at(i));
        }
    }

static void save_txt() {
  // check that image selection from directory is valid
  if (!isSelectionValid()) {
  	std::cout << "error failed to save sel_file out of bounts [" << sel_file << ": " << filesW.size() << "]" << std::endl;
  	return;
  	}

  // check that the save flags are enabled
  if (bit::get(write_txt, 1) && bit::get(write_txt, 2)) {

  	// create a char buffer and write it to a file
  	bytestream s;
  	s.writeFileW (
  		getFilename::PathW(filesW.at(sel_file)) + getFilename::FileW(filesW.at(sel_file)) + L".txt",
  		0,
  		strlen(textbuf->text()),
  		textbuf->text()
  		);
  	s.close();

  	// append the tags to array
  	//std::vector<std::string> global_tags;
  	unsigned int num_tags = tag_sidebar_pack->children();
  	//Fl_Light_Button* lbtn = nullptr;
  	if (num_tags > 0) {
  	//  		global_tags = std::vector<std::string>(num_tags);
  	//  		for (unsigned int i = 0; i < num_tags; i++) {
  	//  			lbtn = (Fl_Light_Button*)tag_sidebar_pack->child(i);
  	//  			global_tags.at(i) = std::string(lbtn->label());
  	//  			}
  	}

  	// split the tags in the text
  	std::vector<std::string> tmp = getDelimitedTags(std::string(textbuf->text()), true, false);
  	num_tags = tmp.size();
  	for (unsigned int i = 0; i < num_tags; i++) {
  		appendIfUnique<std::string>(global_tags, tmp.at(i));
  		}
  	// add unique tags to array
  	//db.image(sel_file).tags = tmp;

  	// check for changes
  	if (global_tags.size() > 0) {

  		//updates tag list
  		update_tag_buttons();
  		}
  	}


  // check that the save flags are enabled for regions
  //std::cout << "CSV WRite: \t" << bit::get(write_txt, 3) << std::endl;
  //std::cout << "CSV Update: \t" << bit::get(write_txt, 4) << std::endl;
  if (settings->image.at(sel_file).region.size() > 0 && bit::get(write_txt, 3) && bit::get(write_txt, 4)) {
  	std::string csvfile = unicode_to_utf8(filesW.at(sel_file));
  	settings->writeCSV(getFilename::Path(csvfile) + getFilename::File(csvfile) + ".csv", sel_file);
  	}
}

void clear_image() {
  shp_image->image(nullptr);
  shp_image->color(Fl_Color(0));
  shp_image->redraw();

  if (imgbuf != nullptr) {delete imgbuf; imgbuf = nullptr;}
  if (imgtmp != nullptr) {delete imgtmp; imgtmp = nullptr;}

  // Destroy any existing regions
  unsigned int num_regions = shp_image->children();
  if (num_regions > 0) {
  	Fl_Widget* boxregion;
  	for (int i = num_regions; i --> 0; ) {
  		boxregion = shp_image->child(i); // Returns Pointer from Object
  		shp_image->remove(i); // Remove Widget
  		settings->remove(i); // remove from database
  		delete boxregion; // Delete Widget Object
  		}
  	shp_image->redraw();
  	}

  // restore zoom to default
  imgzoom = 1.0f;

  // set write state of the text to false
  write_txt = bit::set(write_txt, 2, false);
  write_txt = bit::set(write_txt, 4, false);

  // clear text buffer
  textbuf->text("");
}

static void readDimFromImage(std::wstring file, unsigned int &width, unsigned int &height) {
  width = 0; height = 0;
  std::wstring fext = toLowerW(getFilename::TypeW(file));
  if (fext == L".png") {
  	bytestream f;
  	if (f.openFileW(file)) {
  		size_t fsize = f.size;
  		if (fsize > 32) {
  			size_t pos = 0;
  			uint32_t csize = f.readUlong();
  			uint32_t type = f.readUlong();
  			if (csize == 0x474E5089 && type == 0x0A1A0A0D) {
  			while (f.tell() < fsize) {
  			csize = f.readUlong();
  			type = f.readUlong();
  			pos = f.tell();
  			if (type == 0x52444849) { // IHDR
  			  width = bit::swapBytes(bit::swapBytes(f.readUlong(), 1, 4), 2, 3);
  			  height = bit::swapBytes(bit::swapBytes(f.readUlong(), 1, 4), 2, 3);
  			  break;
  			  }
  			f.seek(pos + bit::swapBytes(bit::swapBytes(csize, 1, 4), 2, 3));
  			}
  			} else {std::cout << "invalid header\n";}
  			} else {std::cout << "invalid png\n";}
  		f.close();
  		} else {std::wcout << L"failed to open file {" << file << L"}\n";}
  	}
  else if (fext == L".jpg" || fext == L".jpeg") {
  	bytestream f;
  	if (f.openFileW(file)) {
  		size_t fsize = f.size;
  		uint16_t type = f.readUshort();
  		if (type == 0xD8FF) { // SOI, Start of Image
  			// Scan miscellaneous markers until we reach SOF0 marker {0xC0}
  			size_t pos = 0;
  			unsigned int len = 0;
  			bool stop = false;
  			while (stop == false && f.tell() < fsize) {
  				type = f.readUshort();
  				switch (type) {
  					case 0xFEFF: {f.seek(bit::swapBytes(f.readUshort(), 1, 2) - 2, seek::cur); break;} // COM, Comment
  					case 0xD9FF: {stop = true; break;} // EOI, End of Image
  					case 0x0DFF: {continue;} // RST0, Restart
  					case 0x1DFF: {continue;} // RST1, Restart
  					case 0x2DFF: {continue;} // RST2, Restart
  					case 0x3DFF: {continue;} // RST3, Restart
  					case 0x4DFF: {continue;} // RST4, Restart
  					case 0x5DFF: {continue;} // RST5, Restart
  					case 0x6DFF: {continue;} // RST6, Restart
  					case 0x7DFF: {continue;} // RST7, Restart
  					case 0xDAFF: {f.seek(bit::swapBytes(f.readUshort(), 1, 2) - 2, seek::cur); break;} // SOS, Start of Scan
  					case 0xDDFF: {f.seek(4, seek::cur); break;} // DRI, Define Restart Interval
  					case 0xC4FF: {f.seek(bit::swapBytes(f.readUshort(), 1, 2) - 2, seek::cur); break;} // DHT, Define Huffman Tables
  					case 0xDBFF: {f.seek(bit::swapBytes(f.readUshort(), 1, 2) - 2, seek::cur); break;} // DQT, Define Quantization Tables
  					case 0xC0FF: { // S0F0, Start of Frame
  						// this contains the image width and height
  						pos = f.tell();
  						len = bit::swapBytes(f.readUshort(), 1, 2);
  						f.seek(1, seek::cur);
  						height = bit::swapBytes(f.readUshort(), 1, 2);
  						width = bit::swapBytes(f.readUshort(), 1, 2);
  						f.seek(pos + len);
  						stop = true; break;
  						}
  					case 0xC2FF: { // S0F2, Start of Frame
  						// this contains the image width and height
  						pos = f.tell();
  						len = bit::swapBytes(f.readUshort(), 1, 2);
  						f.seek(1, seek::cur);
  						height = bit::swapBytes(f.readUshort(), 1, 2);
  						width = bit::swapBytes(f.readUshort(), 1, 2);
  						f.seek(pos + len);
  						stop = true; break;
  						}
  					default: {
  						if ((type & 0xF0FF) == 0xE0FF) { // APPn, Application specific
  							f.seek(bit::swapBytes(f.readUshort(), 1, 2) - 2, seek::cur);
  							}
  						}
  					}
  				}
  			} else {std::cout << "Invalif JPEG Header\n";}
  		f.close();
  		} else {std::wcout << L"failed to open {" << file << L"}\n";}
  	}
  else if (fext == L".bmp") {
  	bytestream f;
  	if (f.openFileW(file)) {
  		size_t fsize = f.size;
  		if (fsize > 18) {
  			uint16_t type = f.readUshort();
  			if (type == 0x4D42) {
  				f.seek(14);
  				if (f.readUlong() == 40) {
  					width = f.readUlong();
  					height = f.readUlong();
  					} else {std::cout << "not a windows BMP\n";}
  				} else {std::cout << "Invalif BMP Header {" << type << "}\n";}
  			} else {std::cout << "Invalid Header Size\n";}
  		f.close();
  		} else {std::wcout << L"failed to open {" << file << L"}\n";}
  	}
  else {std::wcout << L"unsupported file type {" << fext << L"}\n";}
}

static void readTagsFromFile(std::wstring txt_file, std::vector<std::string> &tags, bool cullDuplicates ) {
  if (os::doesFileExistW(txt_file)) {
      bytestream o;
      if (o.openFileW(txt_file)) {
          std::string str = o.readstring(o.size);
          tags = getDelimitedTags(str, true, true);
//          std::vector<std::string> tmp;
//          unsigned int tmpn;
//
//          while (!o.eos()) {
//              str = trim(o.readline());
//              if (str.size() == 0) {continue;}
//              tmp = split(str, ",");
//              tmpn = tmp.size();
//              for (unsigned int j = 0; j < tmpn; j++) {
//                  tmp.at(j) = trim(tmp.at(j), " ");
//                  tmp.at(j) = trim(tmp.at(j), "\t");
//                  tmp.at(j) = tolower(tmp.at(j));
//                  if (cullDuplicates) {
//                      if (std::find(tags.begin(), tags.end(), tmp.at(j)) == tags.end()) {
//                          tags.push_back(tmp.at(j));
//                          }
//                      } else {tags.push_back(tmp.at(j));}
//                  }
//              }
          o.close();
          }
      }
}

static void writeTagsToFile(std::wstring file, std::vector<std::string> &tags) {
  unsigned int c = tags.size();
  if (file.size() == 0 || c == 0) {return;}
  std::sort(tags.begin(), tags.end());
  std::string txtfile = "";
  for (unsigned int i = 0; i < c; i++) {
  	if (tags.at(i).size() == 0) {continue;}
  	txtfile += tags.at(i);
  	if (i + 1 < c) {txtfile += ", ";}
  	}
  if ((c = txtfile.size()) == 0) {return;}
  bytestream s;
  s.writeFileW(file, 0, c, (char*)txtfile.c_str());
  s.close();
}

static void moveTagsFromPath(std::wstring fpath, std::string tag) {
  /*
      move files into a new folder based on a given tag or tags
  */

  if (!os::doesFileExistW(fpath)) {
      std::cout << "invalid file path\n";
      return;
      }

  // Check tag request is valid
  if (tag.size() == 0) {std::cout << "no tag given\n"; return;}

  // check tag for commas, and delimit them into an array
  std::vector<std::string> ss = getDelimitedTags(tag, false, false);

  // get tag count
  unsigned int sc = ss.size();

  // clean up the tags
  for (unsigned int i = 0; i < sc; i++) {ss.at(i) = tolower(trim(trim(ss.at(i), " "), "\t"));}

  // locate text files to inspect
  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.txt");
  unsigned int num_txt_files = files.size();

  // check each tag text file
  std::vector<std::string> tags;
  std::wstring folder;
  bool doMove = false;
  signed int x = 0;
  unsigned int c = 0;
  std::wstring fext;
  std::wstring newfile;
  std::vector<std::wstring> createdFolders;
  for (unsigned int j = 0; j < num_txt_files; j++) {

      // set default action to NOT move the file
      doMove = false;

      // Read tags from text file
      tags.clear();
      readTagsFromFile(files.at(j), tags, false);

      // for each tag searchable, check text file's tags
      for (unsigned int i = 0; i < sc; i++) {
          // do a search for tag
          x = findItem(tags, ss.at(i));
          if (x > -1) {
              // change move flag to true
              doMove = true;
              break;
              }
          }

      // if move flag true, then move file
      if (doMove) {

          // create new export folder
          folder = fpath + string_to_wstring(tag) + L"\\";

          x = findItem<std::wstring>(createdFolders, folder);
          if (x == -1) {
              // create folder if not already made
              if (!os::doesFileExistW(folder)) {
                  os::makeDirW(folder);
                  }

              createdFolders.push_back(folder);
              }


          // move files
          for (unsigned int k = 0; k < num_img_types; k++) {

              // make filepath to new folder
              newfile = (getFilename::FileW(files.at(j))) + knownTypes[k];

              // skip if no file found
              if (!os::doesFileExistW(fpath + newfile)) {continue;}

              // move file
              os::moveFileW(fpath + newfile, folder + newfile); // move text file

              // update files array
              x = findItem<std::wstring>(filesW, fpath + newfile);
              if (x > -1) {filesW.at(x) = folder + newfile;}

              // count how many things moved
              c++;

              }
          }
      }

  // if any ones moved, inform user of how many were moved
  if (c > 0) {
      //fl_choice((to_string(c) + " files moved under " + tag).c_str(), "OK", 0, 0);
      //os::openPathW(fpath);
      }
}

static void removeTagsFromPath(std::wstring fpath, std::string str, bool doReverse ) {
  // Check tag request is valid
  if (str.size() == 0) {std::cout << "no tag given\n"; return;}

  // split the tags if there is a comma
  std::vector<std::string> ss = getDelimitedTags(str, false, false);
  unsigned int num_tags = ss.size();
  if (num_tags == 0) {return;}

  // clean up tags, remove white space etc
  for (unsigned int i = 0; i < num_tags; i++) {
      ss.at(i) = tolower(trim(trim(ss.at(i), " "), "\t"));
      }

  // cross reference text files in the folder with the tags
  std::vector<std::string> tags;
  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.txt");
  unsigned int num_files = files.size();
  bool doWrite = false;
  std::vector<bool> delList;
  unsigned int c = 0;
  for (unsigned int j = 0; j < num_files; j++) {

      // set default state to NOT write
      doWrite = false;

      // read tags from each text file
      tags.clear();
      readTagsFromFile(files.at(j), tags, true);

      // skip if the text file was empty
      c = tags.size();
      if (c == 0) {continue;}

      // cross reference tags to text files
      delList.clear();
      delList = std::vector<bool>(c);
      for (unsigned int i = 0; i < c; i++) {
          delList.at(i) = true;

          if (doReverse) {
              if (findItem<std::string>(ss, tags.at(i)) < 0) {
                  delList.at(i) = false;
                  doWrite = true;
                  }
              }
          else {
              if (findItem<std::string>(ss, tags.at(i)) > -1) {
                  delList.at(i) = false;
                  doWrite = true;
                  }
              }
          }
      if (doWrite) {
          for (int i = c; i --> 0; ) {
              if (!delList.at(i)) {
                  deleteItem(tags, i);
                  }
              }
          writeTagsToFile(files.at(j), tags);
          }
      }
}

static void addTagsToPath(std::wstring fpath, std::string str) {
  if (str.size() == 0) {return;}

  // Delimit Tags to Add
  std::vector<std::string> tags = getDelimitedTags(str, false, false);
  unsigned int num_tags = tags.size();

  // Collect Text Files From Path
  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.txt");
  unsigned int num_files = files.size();

  // Open each text
  signed int x = 0;
  std::vector<std::string> txttags;
  for (unsigned int j = 0; j < num_files; j++) {

      // read Tags from text file
      txttags.clear();
      readTagsFromFile(files.at(j), txttags, false);

      // check if amendments are required
      for (unsigned int i = 0; i < num_tags; i++) {
          x = findItem(txttags, tags.at(i));

          // needs to be amended
          if (x == -1) {
              txttags.push_back(tags.at(i));
              }
          }

      // flush any changes back to the text
      if (txttags.size() > 0) {
          writeTagsToFile(files.at(j), txttags); // sorting happens inside the function
          }
      }
}

static void ReplaceTagsInPath(std::wstring fpath, std::string strFind, std::string strReplacement) {
  if (fpath.size() == 0 || strFind.size() == 0) {return;}

  // Collect Text Files From Path
  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.txt");
  unsigned int num_files = files.size();

  // Open each text
  signed int x = 0;
  std::vector<std::string> txttags;
  for (unsigned int j = 0; j < num_files; j++) {

      // read Tags from text file
      txttags.clear();
      readTagsFromFile(files.at(j), txttags, false);

      for (unsigned int b = 0; b < txttags.size(); b++) {
          std::cout << "Tag" << b << ": \t(" << txttags.at(b) << ")" << std::endl;
          }


      // check if amendments are required
      x = findItem(txttags, strFind);

      // needs to be amended
      if (x > -1) {
          txttags.at(x) = strReplacement;
          // flush any changes back to the text
          writeTagsToFile(files.at(j), txttags); // sorting happens inside the function
          }
      }
}

static void overwriteTagsInPath(std::wstring fpath, std::string str) {
  str = trim(str, " ");
  if (str.size() == 0) {return;}
  std::wstring fext = L"";
  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.*");
  unsigned int num_files = files.size();
  bool halt = false;
  bytestream s;
  for (unsigned int i = 0; i < num_files; i++) {
  	fext = toLowerW(getFilename::TypeW(files.at(i)));
  	if (fext.size() < 3) {continue;}
  	halt = true;
  	for (unsigned int j = 0; j < 4; j++) {
  		if (knownTypes[j].find(fext) != std::wstring::npos) {
  			halt = false;
  			break;
  			}
  		}
  	if (halt) {continue;}
  	s.writeFileW(fpath + getFilename::FileW(files.at(i)) + L".txt", 0, str.size(), (char*)str.c_str());
  	s.close();
  	}
}

static void binMaps(std::wstring fpath) {
  /*
  	reads each image and distributes them into
  	their own folder based on their dimensions

  	update,
  	replaced openBitMap with readDimFromJPG,
  	openBitMap uses too much memory
  */

  // Copy currently open file
  bool reloadFile = false;
  if (isSelectionValid()) {
  	save_txt();
  	}



  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.*");
  unsigned int num_files = files.size();
  std::vector<unsigned int> aspects;
  std::vector<std::string> folders;
  signed int x = 1;
  unsigned int width = 0;
  unsigned int height = 0;
  unsigned int a = 0;
  std::string n = "";
  unsigned int rw = 0;
  unsigned int rh = 0;
  float d = 2.0f;
  unsigned int twidth;
  unsigned int theight;
  float tw;
  float th;
  float tl = 1.0f;
  unsigned int c;
  float tol = 0.05f;
  bool halt = false;
  std::wstring fext;
  std::wstring newfile;
  std::wstring filesearch;
  for (unsigned int j = 0; j < num_files; j++) {

  	if (files.at(j) == L"." || files.at(j) == L"..") {continue;}

  	// check that the image is of a supported file type
  	fext = toLowerW(getFilename::TypeW(files.at(j)));
  	halt = true;
  	for (unsigned int i = 0; i < 4; i++) {
  		if (fext == knownTypes[i]) {
  			halt = false;
  			break;
  			}
  		}

  	// skip if file isn't supported
  	if (halt) {
  		//std::wcout << "halted " <<  files.at(j) << std::endl;
  		continue;
  		}

  	// skip file if file was already moved
  	if (!os::doesFileExistW(files.at(j))) {
  		//std::wcout << "cant finf ggile " <<  files.at(j) << std::endl;
  		continue;
  		}


  	// read the iamge's dimensions

  	readDimFromImage(files.at(j), width, height); // could replace this with FLTK's native image reader

  	if (width <= 0 || height <= 0) {
  		//std::cout << "incorrect dim\n";
  		return;
  		}

  	// calculate image's aspect ratio
  	d = 2.0f;
  	twidth = ((unsigned int)(width / 2.0)) * 2;
  	theight = ((unsigned int)(height / 2.0)) * 2;
  	tw = (float)width;
  	th = (float)height;
  	rw = (unsigned int)tw;
  	rh = (unsigned int)th;
  	c = 1;
  	while (tw >= tl && th >= tl) {
  		tw = twidth / (c * d);
  		th = theight / (c * d);
  		if ((tw - ((float)((unsigned int)tw))) <= tol && (th - ((float)((unsigned int)th))) <= tol) {
  			rw = (unsigned int)tw;
  			rh = (unsigned int)th;
  			}
  		c++;
  		}

  	// check the image dimensions are valid
  	if (rw > 0 && rh > 0) {

  		// check if aspect ratio is new
  		a = (unsigned int)(((float)rw / (float)rh) * 1000);
  		x = findItem(aspects, a);

  		// add new entry
  		if (x == -1) {

  			// create a new folder if needed
  			n = to_string(rw) + " x " + to_string(rh);
  			if (!os::doesFileExistW(fpath + string_to_wstring(n) + L"\\")) {
  				os::makeDirW(fpath + string_to_wstring(n) + L"\\");
  				}

  			// append data
  			x = aspects.size();
  			folders.push_back(n);
  			aspects.push_back(a);
  			}

  		// create destination path
  		newfile = fpath + string_to_wstring(folders[x]) + L"\\" + getFilename::FileW(files.at(j));
  		filesearch = fpath + getFilename::FileW(files.at(j));

  		// search known types and move them
  		for (unsigned int k = 0; k < num_img_types; k++) {

  			if (!os::doesFileExistW(filesearch + knownTypes[k])) {
  				//std::wcout << L"Fail, cant find file: \t" << filesearch << knownTypes[k] << std::endl;
  				continue;
  				}

  			// move file to the given location
  			os::moveFileW(filesearch + knownTypes[k], newfile + knownTypes[k]);


  			// check if the file is one of the currently opened files
  			x = findItem<std::wstring>(filesW, filesearch + knownTypes[k]);

  			// update file names
  			if (x > -1) {
  				filesW.at(x) = newfile + knownTypes[k];
  				if (x == sel_file) {reloadFile = true;}
  				// set flag to reload later
  				//if (!reloadFiles) {reloadFiles = true;}
  				}
  			}
  		}
  	//else {std::cout << "invalid img dim\n";}
  	}

  // check the files should be reloaded
  if (reloadFile && num_files > 0) {

  	// restart by re-opening file
  	read_image(unicode_to_utf8(files.at(sel_file)));
  	}
}

static void renameDataset(std::wstring fpath, std::string prefix ) {
  // check given path is valid
  if (fpath.size() == 0 || !os::doesFileExistW(fpath)) {
      std::cout << "path empty" << std::endl;
      return;
      }

  // get files in given folder
  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.*");
  unsigned int num_files = files.size();

  // count the number of digits from the files count
  unsigned int d = (to_string(num_files)).size();

  // sort files
  //std::sort(files.begin(), files.end());

  // Copy currently open file
  if (isSelectionValid()) {

      // save changes
      save_txt();
      }

  // rename files
  std::wstring fext = L"";


  std::string fname = "";
  std::string n = "";
  std::wstring str;
  bool halt = false;
  signed int x;
  std::vector<std::wstring> filesRen;
  std::wstring fnamew;
  std::wstring newfile;
  for (unsigned int i = 0; i < num_files; i++) {

      // some times the return is three dots? skip if this happens
      if (files.at(i).size() < 4) {continue;}

      // get files extension
      fext = toLowerW(getFilename::TypeW(files.at(i)));

      // set skip state to true
      halt = true;

      // test for known file types
      for (unsigned int j = 0; j < num_img_types; j++) {
          if (knownTypes[j].find(fext) != std::wstring::npos) {
              halt = false;
              break;
              }
          }

      // skip if file type is not supported
      if (halt) {continue;}

      // get base name
      fnamew = getFilename::FileW(files.at(i));

      // get index
      x = findItem<std::wstring>(filesRen, fnamew);
      if (x == -1) {
          x = filesRen.size();
          filesRen.push_back(fnamew);
          }

      // create a serilized name
      fname = prefix + " " + padString(to_string(x), d, "0", true);
      newfile = fpath + string_to_wstring(fname) + fext;


      // rename it
      os::renameFileW(files.at(i), newfile);

      // check if the file is already open
      x = findItem<std::wstring>(filesW, files.at(i));

      // update filename
      if (x > -1 ) {

          // don't need to reload anything, just rename the UI info for the currently open file
          if (x == sel_file) {

              // convert wchar to char
              fname = wstring_to_string(newfile);

              // Add info to the Title bar and Status Bar
              lb_file->value((getFilename::FromPath(fname)).c_str());
              SetWindowTextA(xid, lb_file->value());

              }

          filesW.at(x) = newfile;
          }
      }
  //os::openPathW(fpath);
}

static void getTagsFromPathOfTxt(std::wstring fpath) {
  // check there is a default path
  if (!os::doesFileExistW(fpath)) {
  	fl_choice("Path Not Set", "OK", 0, 0);
  	std::vector<std::string> tmp;
  	return;
  	}

  // Grab the files from the path
  std::vector<std::wstring> files = os::getFilesW(fpath + L"*.txt");
  unsigned int num_files = files.size();
  if (num_files == 0) {
  	std::cout << "no text files in path\n";
  	return;
  	}


  // read in tags from each text
  std::vector<std::string> tags;
  std::vector<std::string> ss;
  unsigned int sc;
  for (unsigned int j = 0; j < num_files; j++) {
  	ss.clear();
  	readTagsFromFile(files.at(j), ss, false);

  	// add unique tags to collection of tags
  	sc = ss.size();
  	for (unsigned int i = 0; i < sc; i++) {

  		ss.at(i) = trim(ss.at(i), " ");
  		ss.at(i) = trim(ss.at(i), "\t");
  		if (ss.at(i).size() == 0) {continue;}
  		ss.at(i) = tolower(ss.at(i));

  		if (std::find(tags.begin(), tags.end(), ss.at(i)) == tags.end()) {
  			tags.push_back(ss.at(i));
  			}
  		}
  	}

  unsigned int num_tags = tags.size();
  if (num_tags == 0) {
  	std::cout << "no tags from text parse\n";
  	return;
  	}

  // sort tags
  std::sort(tags.begin(), tags.end());

  // format tags into text
  std::string text_data = "";
  for (unsigned int i = 0; i < num_tags; i++) {

  	text_data += tags.at(i);
  	if (i + 1 < num_tags) {
  		text_data += ", ";
  		}
  	}
  if (text_data.size() > 0) {

  	bytestream s;
  	std::wstring text_file = fpath + L"gathered tags.txt";
  	s.writeFileW(text_file, 0, text_data.size(), (char*)text_data.c_str());
  	os::start(text_file);
  	//os::deleteFileW(text_file, true);
  	s.close();
  	}
}

static void batch_rename() {
  // check there is a default path
  if (!os::doesFileExistW(work_path)) {
      fl_choice("Path Not Set", "OK", 0, 0);
      return;
      }

  // ask for new name
  const char* input = fl_input("please enter new name");
  if (input != nullptr) {
      renameDataset(work_path, std::string(input));
      }
}

int load_tagfile(std::wstring file) {
    int result = 0;
    bytestream f;
    if ((result = f.openFileW(file))) {

        // Parse what was read from the file
        std::vector<std::string> tags = getDelimitedTags(f.readstring(f.size), true, true);
        //for (unsigned int i = 0; i < tags.size(); i++) {std::cout << "tag" << i << ": \t" << tags.at(i) << std::endl;}
        // check the file isn't empty
        if (tags.size() > 0) {


            // sort and write back to the widget
            unsigned int num_tags = tags.size();
            std::string tmpstr = "";
            if (num_tags > 0) {
                //std::sort(tags.begin(), tags.end());
                //signed int x;
                std::string tag_name;
                Fl_Light_Button* lbtn;
                unsigned int num_tag_btns = tag_sidebar_pack->children();
                for (unsigned int i = 0; i < num_tags; i++) {

                    for (unsigned int j = 0; j < num_tag_btns; j++) {

                        lbtn = (Fl_Light_Button*)tag_sidebar_pack->child(j);
                        tag_name = lbtn->label();
                        if (tag_name == tags.at(i)) {
                            lbtn->set();
                            lbtn->redraw();
                            break;
                            }
                        }
                    //std::cout << "tag" << i << ":\t " << tags.at(i) << std::endl;

                    if (tmpstr.size() == 0) {
                        tmpstr+= tags.at(i);
                        }
                    else {
                        tmpstr+= ", " + tags.at(i);
                        }

                    }

                }
            textbuf->text(tmpstr.c_str());
            }
        f.close();
        }
    return result;
    }

bool load_image() {
    clear_image();

    // update image selection index in database
    settings->selected = sel_file;


    // Check that the index for the files array is in bounds
    if (!isSelectionValid()) {
        std::cout << "index for image array is out of bounds [" << sel_file << ":" << filesW.size() << "]" << std::endl;
        std::cout << "Size: " << filesW.size() << std::endl;
        std::cout << "sel_file: " << sel_file << std::endl;
        std::cout << "sel_file2: " << (unsigned int)(sel_file + 1) << std::endl;
        return false;
        }

    // since windows uses wide characters, and FTLK uses UTF8 convert file to wide (for windows)
    std::string file = unicode_to_utf8(filesW.at(sel_file));

    // Determine file type from naming extension
    std::string fext = tolower(getFilename::Type(file));

    // check if input is a text file
    if (fext == ".txt" || fext == ".csv") {
        std::cout << "warning a none image type was provided, trying to search for nearest image\n";
        // check for iamge file
        std::wstring wstr = filesW.at(sel_file).substr(0, filesW.at(sel_file).find_last_of(L"."));
        if (os::doesFileExistW(wstr + L".jpg")) {
            filesW.at(sel_file) = wstr + L".jpg";
            fext = ".jpg";
            }
        else if (os::doesFileExistW(wstr + L".jpeg")) {
            filesW.at(sel_file) = wstr + L".jpeg";
            fext = ".jpeg";
            }
        else if (os::doesFileExistW(wstr + L".bmp")) {
            filesW.at(sel_file) = wstr + L".bmp";
            fext = ".bmp";
            }
        else if (os::doesFileExistW(wstr + L".png")) {
            filesW.at(sel_file) = wstr + L".png";
            fext = ".png";
            }
        else {
            std::cout << "failed to locate image type\n" << std::endl;
            return false;
            }

        file = unicode_to_utf8(filesW.at(sel_file));
        }

    // Bail if type not supported
    int type = 0;
    if      (fext == ".jpg" || fext == ".jepg") {type=1;}
    else if (fext == ".png")                    {type=2;}
    else if (fext == ".bmp")                    {type=3;}
    else {
        std::cout << "Image Type Not Supported By App [" << fext << "]" << std::endl;
        return false;
        }


    // Load data / render to screen
    switch (type) {
        case 1: {
            Fl_JPEG_Image* jpg = new Fl_JPEG_Image(file.c_str());
            char* errMsg = nullptr;
            size_t errMsgLen = 0;
            switch ( jpg->fail() ) { // Check for Errors
                case Fl_Image::ERR_NO_IMAGE:
                case Fl_Image::ERR_FILE_ACCESS: {
                    strerror_s(errMsg, errMsgLen, errno);
                    fl_alert("%s: %s", file.c_str(), std::string(errMsg).c_str());
                    if (errMsg != nullptr) {delete errMsg;}
                    return false;
                    }
                case Fl_Image::ERR_FORMAT: {fl_alert("%s: couldn't decode image", file.c_str()); return false;}
                }
            imgbuf = jpg->copy(); delete jpg; shp_image->image( imgbuf );
            break;
            }
        case 2: {
            Fl_PNG_Image* png = new Fl_PNG_Image(file.c_str());
            char* errMsg = nullptr;
            size_t errMsgLen = 0;
            switch ( png->fail() ) { // Check for Errors
                case Fl_Image::ERR_NO_IMAGE:
                case Fl_Image::ERR_FILE_ACCESS: {

                    strerror_s(errMsg, errMsgLen, errno);
                    fl_alert("%s: %s", file.c_str(), std::string(errMsg).c_str()); break;
                    if (errMsg != nullptr) { delete errMsg; }
                    return false;
                    }
                case Fl_Image::ERR_FORMAT: {fl_alert("%s: couldn't decode image", file.c_str()); return false;}
                }
            imgbuf = png->copy(); delete png; shp_image->image( imgbuf );
            break;
            }
        case 3: {
            Fl_BMP_Image* bmp = new Fl_BMP_Image(file.c_str());
            char* errMsg = nullptr;
            size_t errMsgLen = 0;
            switch ( bmp->fail() ) { // Check for Errors
                case Fl_Image::ERR_NO_IMAGE:
                case Fl_Image::ERR_FILE_ACCESS: {
                    strerror_s(errMsg, errMsgLen, errno);
                    fl_alert("%s: %s", file.c_str(), std::string(errMsg).c_str()); break;
                    if (errMsg != nullptr) { delete errMsg; }
                    return false;
                    }
                case Fl_Image::ERR_FORMAT: {
                    fl_alert("%s: couldn't decode image", file.c_str());
                    return false;
                    }
                }
            imgbuf = bmp->copy(); delete bmp; shp_image->image( imgbuf );
            break;
            }
        default: {
            std::cout << "unsupported type\n";
            return false;
            }
        }



    //    settings->regions.clear();

    //std::cout << "Regions Left: \t" << shp_image->children() << std::endl;





    // check that the number of arrays is larger then 0
    /*
        imgm5d = "3B5D3C7D207E37DCEEEDD301E35E2E58";

        if (imgbuf->count() > 0) { // there can be more then one pixel array for a given image

        // Calculate the theortical size, I didn't understand what the doc said able ld() tho so might not work
        unsigned int buf_size = imgbuf->w() * imgbuf->h() * imgbuf->d();

        if (buf_size > 0) {
        // read the first buffer pointer to the RGB data, I didnt understand what the doc said about multiple image arrays, sooo
        const char* buf = static_cast<const char*>( *imgbuf->data() );

        // Should be able to read the pixels, check with d() to get how many channels RGB(3) or RGBA(4)
        //for (unsigned int i = 0; i < 12; i++) {std::cout << i << ": \t" << (int)(unsigned char)buf[i] << std::endl;}

        // Create a MD5 checksum from the pixel array
        imgm5d = md5(buf, buf_size);
        //std::cout << "GENERATED MD5: \t" << imgm5d << std::endl;
        // add image to database
        //settings->addImage(file, imgm5d, imgbuf->w(), imgbuf->h(), "");
        }
        }
    */



    // Set Zoom out Limit
    imgmin_limit = imgmin_limit_default;
    if (imgbuf->w() < imgmin_limit && imgbuf->w() > 0) {imgmin_limit = imgbuf->w();}
    if (imgbuf->h() < imgmin_limit && imgbuf->h() > 0) {imgmin_limit = imgbuf->h();}

    // calculate zoom ratio
    img_resize();

    // resize mage
    img_rescale();

    // Set Image Start Position
    imgpos[0] = tile_view->x() + (tile_view->w() / 2) - (shp_image->w() / 2);
    imgpos[1] = tile_view->y() + (tile_view->h() / 2) - (shp_image->h() / 2);

    // Update Image Position
    shp_image->position(imgpos[0], imgpos[1] );


    // Load any regions from previous
    //settings->set(image_data(imgm5d, file, "", imgbuf->w(), imgbuf->h()));

    settings->loadCSV(getFilename::Path(file) + getFilename::File(file) + ".csv", sel_file);

    unsigned int reg_count = settings->count();
    if (reg_count > 0) {

        signed int img_center_x = shp_image->x() + (shp_image->w() / 2);
        signed int img_center_y = shp_image->y() + (shp_image->h() / 2);

        for (unsigned int  i = 0; i < reg_count; i++) {

            //std::cout << "CSV Region: (" << settings->image.at(sel_file).region.at(i).x << ", ";
            //std::cout << settings->image.at(sel_file).region.at(i).y << ", ";
            //std::cout << settings->image.at(sel_file).region.at(i).w << ", ";
            //std::cout << settings->image.at(sel_file).region.at(i).h << ")" << std::endl;

            Resizeable* boxregion = (
                new Resizeable(
                    (signed int)((float)((settings->image.at(sel_file).region.at(i).x - (settings->image.at(sel_file).region.at(i).w * 0.5f)) * imgzoom) + img_center_x),
                    (signed int)((float)((settings->image.at(sel_file).region.at(i).y - (settings->image.at(sel_file).region.at(i).h * 0.5f)) * imgzoom) + img_center_y),
                    (signed int)((float)settings->image.at(sel_file).region.at(i).w * imgzoom),
                    (signed int)((float)settings->image.at(sel_file).region.at(i).h * imgzoom),
                    settings->image.at(sel_file).region.at(i).tag.c_str()
                    )
                );
            //                    boxregion->box(FL_NO_BOX);
            //boxregion->labelfont(5);
            if (bit::get(visiblity, 1)) {boxregion->show();} else {boxregion->hide();}

            //                        boxregion->selection_color((Fl_Color)14);
            //boxregion->image(G_cat);
            boxregion->box(FL_NO_BOX);
            //                        boxregion->color(Fl_Color(46));

            boxregion->labelcolor(fl_rgb_color(255, 255, 0));
            boxregion->labelfont(FL_HELVETICA_BOLD);
            boxregion->labeltype(FL_ENGRAVED_LABEL);
            boxregion->labelsize(14);
            //boxregion->copy_label(tag_name.c_str());
            //boxregion->callback((Fl_Callback*)tags_btn_update, (void*)boxregion->label());
            shp_image->add(boxregion);
            boxregion->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
            boxregion->when(FL_WHEN_RELEASE);
            //        boxregion->resizable(shp_image);

            //boxregion->copy_label(tag_name.c_str());
            //boxregion->callback((Fl_Callback*)tags_btn_update, (void*)boxregion->label());
            shp_image->add(boxregion);



            shp_image->redraw();
            boxregion->redraw();

            // Create a new region, not sure I even have to given it a position??
            //float invzoom = 1.0f / imgzoom;

            //settings->add(
            //    region_data(
            //        settings->width(i) * invzoom,
            //       settings->height(i) * invzoom,
            //       settings->posx(i) * invzoom,
            //       settings->posy(i) * invzoom,
            //       settings->name(i)
            ////       )
            //   );

            }


        }



    // Add info to the Title bar and Status Bar
    lb_file->value((getFilename::FromPath(file)).c_str());
    SetWindowTextA(xid, lb_file->value());

    std::string info = to_string(imgbuf->w());
    info += " x ";
    info += to_string(imgbuf->h());
    if (fext.size() > 0) {info += " " + fext.substr(1);}
    lb_info->value(info.c_str());

    info = to_string((int)(imgzoom * 100)) + "%";
    lb_zoom->value(info.c_str());

    info = to_string(sel_file + 1) + "/" + to_string(num_files);
    lb_page->value(info.c_str());

    info = "";
    size_t imgsize = os::getFileSizeW(filesW.at(sel_file));
    if (imgsize > 999999) {info += floatToString((float)imgsize / 1000000.0f) + " mb";}
    else if (imgsize > 999) {info += floatToString((float)imgsize / 1000.0f) + " kb";}
    else {info += to_string(imgsize) + " bytes";}
    lb_fsize->value(info.c_str());

    // toggle off all buttons
    Fl_Light_Button* lbtn;
    unsigned int num_tag_btns = tag_sidebar_pack->children();
    for (unsigned int i = 0; i < num_tag_btns; i++) {
        lbtn = (Fl_Light_Button*)tag_sidebar_pack->child(i);
        lbtn->clear();
        lbtn->redraw();
        }

    // Check for Text file
    std::wstring txtfile = getFilename::PathW(filesW.at(sel_file)) + getFilename::FileW(filesW.at(sel_file)) + L".txt";
    if (os::doesFileExistW(txtfile)) {load_tagfile(txtfile);}

    // Redraw all widgets
    redraw_ui();
    return true;
    }

bool read_image(std::string file) {



  // fetch files from directory
  std::wstring fileW = utf8_2_unicode(file);
  std::wstring fpathW = getFilename::PathW(fileW);
  filesW = os::getFilesW(fpathW + L"*.*");

  // remove any unsupported file types by extension
  sel_file = -1;
  num_files = filesW.size();
  std::wstring fextW;
  for (unsigned int i = num_files; i --> 0; ) {
      fextW = toLowerW(getFilename::TypeW(filesW.at(i)));
      if (!(fextW == L".jpg" || fextW == L".jpeg" || fextW == L".bmp" || fextW == L".png")) {
          filesW.erase(filesW.begin() + i);
          }
      }

  // Check files array is not empty
  num_files = filesW.size();
  //std::cout << "num_files: \t" << num_files << std::endl;
  //for (unsigned int i = 0; i < num_files; i++) {
  //    std::wcout << L"file" << i << ": \t" << filesW.at(i) << std::endl;
  //    }
  if (num_files == 0) {
      std::cout << "no files\n";
      return false;
      }

  // sort files
  std::sort(filesW.begin(), filesW.end());

  // find previously opened file in the files array
  std::string file_tmp = getFilename::FromPath(file);
  for (unsigned int i = num_files; i --> 0; ) {
      if (file_tmp == getFilename::FromPath(unicode_to_utf8(filesW.at(i)))) {
          settings->selected = sel_file = i;
          break;
          }
      // if (.find(fileW) != std::string::npos) {sel_file = i; break;}
      }

  // check if the file was located in the files array
  if (sel_file < 0 || num_files == 0 || (unsigned int)(sel_file + 1) > num_files) {
      std::cout << "failed to index file\n";
      return false;
      }

  // reset images array
  settings->image.clear();
  settings->image = std::vector<image_data>(num_files);
  settings->selected  = 0;

  // add current file to recents list
  if (settings->recents.size() >= 10) {

      // check that the file is unique to the

      signed int x = findItem(settings->recents, file);

      if (x > -1) {
          // shift down the items in the recents list
          unsigned int z = 9;
          for (unsigned int i = 10; i --> 1; ) {
              if (i != (unsigned int)x) {
                  settings->recents.at(i) = settings->recents.at(z);
                  if (z == 0) {break;}
                  z--;
                  }
              }
          }
      else {
          // shift down the items in the recents list
          for (unsigned int i = 10; i --> 1; ) {
              settings->recents.at(i) = settings->recents.at(i - 1);
              }
          }

      // insert new name into list
      settings->recents.at(0) = file;
      settings->save_recents_as_ini();

      // populate list
      rebuild_mnu_recents();
      } else {std::cout << "not enough recents\n";}



  // Get the current folder, path used later to file management
  root_path = fpathW;
  work_path = fpathW;
    global_tags.clear();
  if (num_files > 0) {
      //std::vector<std::string> tags_in_folder;
      for (unsigned int i = 0; i < num_files; i++) {
          readTagsFromFile (root_path + getFilename::FileW(filesW.at(i)) + L".txt", global_tags, true);
          }
      update_tag_buttons();
      }

  // render current image that was indexed in the files array
  return load_image();
}
// >>>>>>>>>>>   CUSTOM WIDGETS    <<<<<<<<<<<<

/**
 Adds a Multi Label to menu to have an image
*/
static void add_multi_label(Fl_Menu_Item* &o, Fl_Image* image) {
  const char* l = o->label();
  o->image(image);
  Fl_Multi_Label *ml = new Fl_Multi_Label;
  ml->typea  = _FL_IMAGE_LABEL;
  ml->labela = (const char*)image;
  ml->typeb  = FL_NORMAL_LABEL;
  ml->labelb = (char*)l;
  ml->label(o);
  o->label(_FL_MULTI_LABEL , (const char *)ml);
}

/**
 generate dark theme pallete
*/
static void get_init_theme(HWND win_hwnd ) {
  int N = 4 + FL_NUM_GRAY;
  r = std::vector<unsigned char> (N, 0);
  g = std::vector<unsigned char> (N, 0);
  b = std::vector<unsigned char> (N, 0);

  // store default (OS-dependent) interface colors:
  Fl::get_system_colors();
  Fl::get_color(FL_BACKGROUND_COLOR, r[0], g[0], b[0]);
  Fl::get_color(FL_BACKGROUND2_COLOR, r[1], g[1], b[1]);
  Fl::get_color(FL_FOREGROUND_COLOR, r[2], g[2], b[2]);
  Fl::get_color(FL_SELECTION_COLOR, r[3], g[3], b[3]);

  for (int i = 0; i < FL_NUM_GRAY; i++) {
      Fl::get_color(fl_gray_ramp(i), r[4 + i], g[4 + i], b[4 + i]);
      }

  if (win_hwnd != nullptr) {xid = win_hwnd;}
}

Resizeable::Resizeable(int X, int Y, int W, int H, const char*l) : Fl_Box(X,Y,W,H,l) {
  //image(G_cat);
  box(FL_UP_BOX);
  can_resize = false;
  is_on_right_bottom_corner = false;
  org[0] = 0;
  org[1] = 0;
  color(FL_GRAY);
}

void Resizeable::draw() {
  Fl_Box::draw();
  fl_rect(x(), y(), w(), h(), FL_RED);
  int bottom_right_x = w() + x();
  int bottom_right_y = h() + y();
  fl_polygon(
      bottom_right_x - 6, bottom_right_y - 1,
      bottom_right_x - 1, bottom_right_y - 6,
      bottom_right_x -1, bottom_right_y - 1
      );
}

int Resizeable::handle(int event) {
  switch (event) {
      case FL_PUSH: {

          can_resize = is_on_right_bottom_corner;
          org[0] = Fl::event_x(); org[1] = Fl::event_y();

          if (Fl::event_button() == FL_LEFT_MOUSE) {
              if (Fl::event_state() & FL_ALT) {


                  switch ( fl_choice("Remove Box?", "OK", "Cancel", 0) ) {
                      case 0: {
                          if (settings->image.size() > 0 && (unsigned int)sel_file < settings->image.size()) {

                              if ((box_index = shp_image->find(this)) > -1) { // get widget's child index from pointer




                                  Fl_Widget* boxregion = shp_image->child(box_index); // Returns Pointer from Object
                                  shp_image->remove(box_index); // Remove Widget
                                  settings->remove(box_index); // Remove From Database
                                  delete boxregion; // Delete Widget Object
                                  shp_image->redraw();

                                  // store the region relative to the parent group, from each there respective centers
                                  if (!bit::get(write_txt, 4)) {write_txt = bit::set(write_txt, 4, true);}
                                  }
                              }
                          break;
                          }
                      case 1: {break;} // no
                      }

                  }


              else if (Fl::event_clicks() > 0) {

                  if ((box_index = shp_image->find(this)) > -1) { // get widget's child index from pointer


                      if (settings->image.size() > 0 && (unsigned int)sel_file < settings->image.size()) {

                          const char* input = fl_input("Name", settings->image.at(sel_file).region.at(box_index).tag.c_str());

                          if (input != nullptr) {
                              settings->image.at(sel_file).region.at(box_index).tag = (std::string)input;
                              settings->image.at(sel_file).region.at(box_index).tag = trim(settings->image.at(sel_file).region.at(box_index).tag, " ");
                              settings->image.at(sel_file).region.at(box_index).tag = tolower(settings->image.at(sel_file).region.at(box_index).tag);
                              if (settings->image.at(sel_file).region.at(box_index).tag.size() > 0) {

                                  copy_label(settings->image.at(sel_file).region.at(box_index).tag.c_str());

                                  // store the region relative to the parent group, from each there respective centers
                                  if (!bit::get(write_txt, 4)) {write_txt = bit::set(write_txt, 4, true);}

                                  std::vector<std::string> tmp = split(std::string(textbuf->text()), ",");
                                  unsigned int numtags = tmp.size();
                                  bool needToAddTag = true;
                                 // std::cout << "needToAddTag: \t" << needToAddTag << std::endl;
                                  for (unsigned int i = 0; i < numtags; i++) {
                                      if (trim(tmp.at(i), " ") == settings->image.at(sel_file).region.at(box_index).tag) {
                                          needToAddTag = false;
                                          break;
                                          }
                                      }
                                  if (needToAddTag) {

                                      if (!bit::get(write_txt, 2)) {write_txt = bit::set(write_txt, 2, true);}
                                      settings->image.at(sel_file).tag.push_back(settings->image.at(sel_file).region.at(box_index).tag);
                                      std::string tags_text = textbuf->text();
                                      tags_text = trim(tags_text, "\n\r ");


                                      if (tags_text.size() > 0) {
                                          if (tags_text.substr(tags_text.size() - 1, 1) != ",") {
                                              tags_text += ", ";
                                              }
                                          tags_text += settings->image.at(sel_file).region.at(box_index).tag;
                                          }
                                      textbuf->text(tags_text.c_str());
                                      edt_sdtags->redraw();
                                      }

                                  }
                              redraw();

                              }




                          }



                      }

                  }


              }

          return 1;
          }
      case FL_RELEASE: {
          can_resize = false;
          keycombo[1] = keycombo[0]; keycombo[0] = Fl::event_key();
          return 1;
          }
      case FL_DRAG: {
          if (can_resize) {
              int X = Fl::event_x();
              int Y = Fl::event_y();
              int W = X > x() + 1 ? X - x() : w();
              int H = Y > y() + 1 ? Y - y() : h();

              size(W, H);

              box_index = shp_image->find(this);
              //unsigned int numregions = shp_image->children();
              //for (unsigned int i = 0; i < numregions; i++) {
              //    if (shp_image->child(i) == this) {
              //        box_index = i;
              //        break;
              //        }
              //    }
              //
              //std::cout << "box_index: \t" << box_index << " \t (" << shp_image->find(this) << ")" << std::endl;

              if (settings->image.size() > 0 && (unsigned int)sel_file < settings->image.size() && box_index > -1 && (unsigned int)box_index < settings->image.at(sel_file).region.size()) {
                  float invzoom = 1.0f / imgzoom;

                  // store the region relative to the parent group, from each there respective centers
                  if (!bit::get(write_txt, 4)) {write_txt = bit::set(write_txt, 4, true);}

                  settings->edit(
                      box_index,
                      (signed int)((float)((x() + (w() * 0.5f)) - (shp_image->x() + (shp_image->w() * 0.5f))) * invzoom),
                      (signed int)((float)((y() + (h() * 0.5f)) - (shp_image->y() + (shp_image->h() * 0.5f))) * invzoom),
                      (signed int)((float)w() * invzoom),
                      (signed int)((float)h() * invzoom)
                      );
                  }

              parent()->redraw();
              redraw_ui();
              }
          else if (Fl::event_button() == FL_LEFT_MOUSE) {



              // Calculate the offset dragged from last click (origin)
              int X = Fl::event_x() - org[0];
              int Y = Fl::event_y() - org[1];

              // Add offset to position
              position(x() + X,  y() + Y);

              // Update the position of the region
              // (old_coordinate_x - focus_point_around_which_scale_is_done_x)*scale_factor + focus_point_around_which_scale_is_done_x = new_coordinate_

              box_index = shp_image->find(this);
              if (box_index > -1) {

                  // Set Write Flag
                  if (!bit::get(write_txt, 4)) {write_txt = bit::set(write_txt, 4, true);}

                  float invzoom = 1.0f / imgzoom;

                  settings->edit(
                      box_index,
                      (signed int)((float)((x() + (w() * 0.5f)) - (shp_image->x() + (shp_image->w() * 0.5f))) * invzoom),
                      (signed int)((float)((y() + (h() * 0.5f)) - (shp_image->y() + (shp_image->h() * 0.5f))) * invzoom),
                      (signed int)((float)w() * invzoom),
                      (signed int)((float)h() * invzoom)
                      );

                  }

              // Update Origin with the last dragged position
              org[0] = Fl::event_x(); org[1] = Fl::event_y();

              // Redraw the UI
              redraw();
              parent()->redraw();
              redraw_ui();
              }
          return 1;
          }
      case FL_MOVE: {
          int dist_right_border  = std::abs(x() + w() - Fl::event_x());
          int dist_bottom_border = std::abs(y() + h() - Fl::event_y());
          is_on_right_bottom_corner = (dist_right_border < 10 && dist_bottom_border < 10);
          window()->cursor(is_on_right_bottom_corner ? FL_CURSOR_SE : FL_CURSOR_DEFAULT);
          return 1;
          }
      case FL_ENTER: {
          return 1;
          }
      case FL_LEAVE: {
          window()->cursor(FL_CURSOR_DEFAULT);
          return 1;
          }
      }
  return 0;
}

Fl_Text_EditorDC::Fl_Text_EditorDC(int X,int Y,int W,int H,const char*l) : Fl_Text_Editor(X,Y,W,H,l) {
}

int Fl_Text_EditorDC::handle(int e) {
  switch ( e ) {
  	case FL_DND_DRAG: {return 1;}
  	case FL_PASTE: {

  		read_image(Fl::event_text());
  		return 1;
  		}
  	case FL_KEYDOWN: {
  		if (box_draw) {break;}
  		if (debug) {std::cout << "EDITOR PRESS {" << Fl::event_key() << "}\n";}

  		// store the last key strokes
  		keycombo[1] = keycombo[0]; keycombo[0] = Fl::event_state();


        //if (Fl::event_key() == ',') {}
  		// try to do auto complete some how..
  		//tag_word += Fl::event_key();
  		//if (Fl::event_key() == ',') {tag_word = "";}
  		//std::cout << tag_word << std::endl;


  		break;
  		}
  	case FL_KEYUP: {
  		if (box_draw) {break;}
  		if (debug) {std::cout << "EDITOR PRESS RELEASE\n";}
  		// store the last key strokes
  		keycombo[1] = keycombo[0]; keycombo[0] = 0;

  		// Set Text changed flag
  		if (bit::get(write_txt, 1) == true && bit::get(write_txt, 2) == false) {
  			write_txt = bit::set(write_txt, 2, true);
  			}
  		break;
  		}
  	case FL_MOUSEWHEEL: {

  		// resize the text with the mouse wheel
  		if (box_draw) {break;}
  		if (((keycombo[0] & FL_CTRL) || (keycombo[0] == FL_Control_L || keycombo[0] == FL_Control_R)) && Fl::event_y() > edt_sdtags->y()) {
  			edt_font_size += (Fl::event_dy() * -4);
  			if      (edt_font_size < 8)  {edt_font_size = 8;}
  			else if (edt_font_size > 72) {edt_font_size = 72;}
  			edt_sdtags->textsize(edt_font_size);

  			edt_sdtags->redraw();
  			}
  		break;
  		}
  	default: {
  		if (debug) {
  			printf("[%2d] EDITOR = %2d = %s\n", 0, e, fl_eventnames[e]);
  			fflush(stdout);
  			}
  		}
  	}
  return(Fl_Text_Editor::handle(e));
}

Fl_ScrollDC::Fl_ScrollDC(int x,int y,int w,int h) : Fl_Scroll(x,y,w,h) {
}

int Fl_ScrollDC::handle(int e) {
  /*
      i store the last key stroke/event,
      i stored the last two to detect double click or like ctrl shift together
  */
  switch ( e ) {
      case FL_DND_ENTER: {} // return(1) for these events to 'accept' dnd
      case FL_DND_DRAG: {}
      case FL_DND_RELEASE: {return 1;}
      case FL_PASTE: {
          // try to read the file from drag and drop
          read_image(Fl::event_text());
          return 1;
          }
      case FL_RELEASE: {
          // unclicked
          if (Fl::event_button() == FL_LEFT_MOUSE) {
              // update the origin
              img_origin();
              }
          }
      case FL_PUSH: {
          // log keystrokes, so I can detect combinations
          keycombo[1] = keycombo[0];
          keycombo[0] = Fl::event_button();

          // If Right Clicked
          if (keycombo[0] == FL_RIGHT_MOUSE ) {

              // Restore image to center of window widget
              img_restore();

              // Double Clicked, doesnt work need to clear it after a amount of time
              //if (keycombo[1]) {std::cout << "double clocked\n";}
              }

          // If Left Clicked
          else if (keycombo[0] == FL_LEFT_MOUSE ) {
              // Set New Origin Point
              img_origin();
              }

          break;
          }
      case FL_KEYDOWN: {
          // store the last key strokes
          keycombo[1] = keycombo[0];
          keycombo[0] = Fl::event_state();
          break;
          }
      case FL_KEYUP: {
          // store the last key strokes
          keycombo[1] = keycombo[0];
          keycombo[0] = 0;
          break;
          }
      case FL_MOUSEWHEEL: {
          //tag_sidebar->redraw();
          redraw_ui();
          /*
          // Bail, if nothing in image buffer
          if (imgbuf == nullptr) {break;}

          // check which widget the cursor's at
          if (Fl::event_y() < edt_sdtags->y()) {

          // Check if Control Key is was Pressed
          if ( keycombo[0] & FL_CTRL) {

          // Scale Image
          img_scale();
          }
          else {
          // Save Text
          save_txt();

          // Load next Image in the directory from the files array
          if (Fl::event_dy() > 0) {sel_file++;} else {sel_file--;}
          if (sel_file < 0) {sel_file = 0;} else if ((unsigned)(sel_file + 1) > num_files) {sel_file = num_files - 1;}
          load_image();
          }
          return 1;
          }
          */
          break;
          }

      // for debugging
      default: {
          if (debug) {
              //    if (mousecur != Fl_Cursor::FL_CURSOR_DEFAULT) {
              //        mousecur = Fl_Cursor::FL_CURSOR_DEFAULT;
              //        win_main->cursor(mousecur);
              //        win_main->redraw();
              //        }
              //    keycombo[1] = keycombo[0];
              //    keycombo[0] = 0;
              printf("[%2d] SCROLL MISSED = %2d = %s\n", 0, e, fl_eventnames[e]);
              fflush(stdout);
              }
          }
      }
  return(Fl_Scroll::handle(e));
}

Fl_GroupDC::Fl_GroupDC(int X,int Y,int W,int H,const char*l) : Fl_Group(X,Y,W,H,l) {
}

int Fl_GroupDC::handle(int e) {
  /*
      i store the last key stroke/event,
      i stored the
      last two to detect double click or like ctrl shift together
  */
  switch (e) {
      case FL_RELEASE: {
          // unclicked
          keycombo[1] = keycombo[0] = 0;

          if (box_draw) {
              box_draw = false;
              std::cout << "Region Pos: [" << boxorg[0] - shp_image->x() << " \t " << boxorg[1] - shp_image->y() << std::endl;

              // adding new region
              if (settings != nullptr && settings->image.size() > 0 && sel_file < (signed int)settings->image.size() && box_index > -1 && box_index < (signed int)settings->image.at(sel_file).region.size()  ) {
                  Resizeable* boxregion = (Resizeable*)shp_image->child(box_index);

                  if (boxregion->label() == nullptr || (std::string)boxregion->label() == "") {

                      const char* input = fl_input("Name", settings->image.at(sel_file).region.at(box_index).tag.c_str());

                      if (input != nullptr) {
                          settings->image.at(sel_file).region.at(box_index).tag = (std::string)input;
                          settings->image.at(sel_file).region.at(box_index).tag = trim(settings->image.at(sel_file).region.at(box_index).tag, " ");
                          settings->image.at(sel_file).region.at(box_index).tag = tolower(settings->image.at(sel_file).region.at(box_index).tag);

                          boxregion->copy_label(settings->image.at(sel_file).region.at(box_index).tag.c_str());
                          if (settings->image.size() > 0 && (unsigned int)sel_file < settings->image.size()) {



                              // store the region relative to the parent group, from each there respective centers
                              if (!bit::get(write_txt, 4)) {write_txt = bit::set(write_txt, 4, true);}


                              std::vector<std::string> tmp = split(std::string(textbuf->text()), ",");
                              unsigned int numtags = tmp.size();
                              bool needToAddTag = true;
                              //std::cout << "needToAddTag: \t" << needToAddTag << std::endl;
                              for (unsigned int i = 0; i < numtags; i++) {
                                  if (trim(tmp.at(i), " ") == settings->image.at(sel_file).region.at(box_index).tag) {
                                      needToAddTag = false;
                                      break;
                                      }
                                  }
                              if (needToAddTag) {

                                  if (!bit::get(write_txt, 2)) {write_txt = bit::set(write_txt, 2, true);}
                                  settings->image.at(sel_file).tag.push_back(settings->image.at(sel_file).region.at(box_index).tag);
                                  std::string tags_text = textbuf->text();
                                  tags_text = trim(tags_text, "\n\r ");


                                  if (tags_text.size() > 0) {
                                      if (tags_text.substr(tags_text.size() - 1, 1) != ",") {
                                          tags_text += ", ";
                                          }
                                      tags_text += settings->image.at(sel_file).region.at(box_index).tag;
                                      }
                                  textbuf->text(tags_text.c_str());
                                  edt_sdtags->redraw();
                                  }

                              }
                          redraw();

                          }

                      }

                  }
              }
          else {
              if (Fl::event_button() == FL_LEFT_MOUSE) {
                  // update the origin
                  img_origin();
                  }
              }
          }
      case FL_PUSH: {
          // log keystrokes, so I can detect combinations
          keycombo[1] = keycombo[0]; keycombo[0] = Fl::event_button();

          if (keycombo[0] == FL_LEFT_MOUSE && (keycombo[1] == FL_Control_L || keycombo[1] == FL_Control_R)) {


              if (!box_draw) {
                  box_draw = true;


                  // Set Write Flag
                  if (!bit::get(write_txt, 4)) {write_txt = bit::set(write_txt, 4, true);}

                  boxorg[0] = Fl::event_x();
                  boxorg[1] = Fl::event_y();
                  box_index = shp_image->children();


                  Resizeable* boxregion = (
                      new Resizeable(boxorg[0], boxorg[1], 10, 10)
                      );

  		if (bit::get(visiblity, 1)) {boxregion->show();} else {boxregion->hide();}
                  //                    boxregion->box(FL_NO_BOX);
                  boxregion->labelfont(12);


                  //                        boxregion->selection_color((Fl_Color)14);
                  //boxregion->image(G_cat);
                  boxregion->box(FL_NO_BOX);
                  //                        boxregion->color(Fl_Color(46));


                  boxregion->labelcolor(fl_rgb_color(255, 255, 0));
                  boxregion->labelfont(FL_HELVETICA_BOLD);
                  boxregion->labeltype(FL_ENGRAVED_LABEL);
                  boxregion->labelsize(14);
                  //boxregion->copy_label(tag_name.c_str());
                  //boxregion->callback((Fl_Callback*)tags_btn_update, (void*)boxregion->label());
                  shp_image->add(boxregion);
                  boxregion->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
                  boxregion->when(FL_WHEN_RELEASE);
                  //        boxregion->resizable(shp_image);

                  //boxregion->copy_label(tag_name.c_str());
                  //boxregion->callback((Fl_Callback*)tags_btn_update, (void*)boxregion->label());
                  shp_image->add(boxregion);
                  box_index = shp_image->children() - 1;


                  shp_image->redraw();
                  boxregion->redraw();

                  // Create a new region, not sure I even have to given it a position??
                  float invzoom = 1.0f / imgzoom;

                  settings->add(
                      region_data(
                          10,
                          10,
                          (signed int)((float)((boxorg[0] + 5) - (shp_image->x() + (shp_image->w() / 2))) * invzoom),
                              (signed int)((float)((boxorg[1] + 5) - (shp_image->y() + (shp_image->h() / 2))) * invzoom)
                          )
                      );

                  keycombo[1] = keycombo[0] = 0;
                  return 1; // returning a none 0, converts the push into a DRAG / RELEASE
                  }
              keycombo[1] = keycombo[0] = 0;
              }

          // If Right Clicked
          else if (box_draw == false && keycombo[0] == FL_RIGHT_MOUSE ) {

          // Restore image to center of window widget
          img_restore();

          // Double Clicked, doesnt work need to clear it after a amount of time
          //if (keycombo[1]) {std::cout << "double clocked\n";}
          }
          // If Left Clicked
          else if (box_draw == false && keycombo[0] == FL_LEFT_MOUSE ) {
          // Set New Origin Point
          img_origin();
          }

          break;
          }
      case FL_KEYDOWN: {
          if (box_draw) {break;}
          // store the last key strokes
          if (debug) {std::cout << "IMAGE PRESS\n";}
          keycombo[1] = keycombo[0];
          keycombo[0] = Fl::event_key();



          break;
          }
      case FL_DRAG: {
          if (box_draw && box_index > -1) {


              Resizeable* boxregion = (Resizeable*)shp_image->child(box_index);
              if (boxregion != nullptr) {
                  signed int boxpos[2] = {Fl::event_x(), Fl::event_y()};
                  signed int box_width = boxpos[0] - boxorg[0];
                  signed int box_height = boxpos[1] - boxorg[1];
                  signed int box_center[2] = {
                      boxorg[0] + (box_width / 2),
                      boxorg[1] + (box_height / 2)
                      };

                  if (box_width < 0) {box_width = -box_width;}
                  if (box_height < 0) {box_height = -box_height;}

                  boxregion->resize(box_center[0] - (box_width / 2), box_center[1] - (box_height / 2), box_width, box_height);



                  // huh this doesn't even get called???? arg

                  float invzoom = 1.0f / imgzoom;

                  // Set Write Flag
                  if (!bit::get(write_txt, 4)) {write_txt = bit::set(write_txt, 4, true);}

                  //std::cout << "THIS: \t" << box_index << " / " << settings->image.at(sel_file).region.size() << std::endl;
                  settings->edit(
                      box_index,
                      (signed int)((float)((boxregion->x() + (box_width / 2)) - (shp_image->x() + (shp_image->w() / 2))) * invzoom),
                      (signed int)((float)((boxregion->y() + (box_height / 2)) - (shp_image->y() + (shp_image->h() / 2))) * invzoom),
                      (signed int)((float)box_width * invzoom),
                      (signed int)((float)box_height * invzoom)
                      );


                  redraw_ui();
                  boxregion->redraw();
                  }
              }
          break;
          }
      case FL_KEYUP: {
          keycombo[1] = keycombo[0] = 0;
          if (box_draw) {break;}
          if (debug) {std::cout << "IMAGE PRESS RELEASE\n";}
          // store the last key strokes
          //            keycombo[1] = keycombo[0];
          //            keycombo[0] = Fl::event_key();

          break;
          }
      case FL_MOUSEWHEEL: {

          if (box_draw) {break;}

          // Bail, if nothing in image buffer
          if (imgbuf == nullptr) {break;}

          // check which widget the cursor's at
          if (Fl::event_y() < edt_sdtags->y()) {

              // Check if Control Key is was Pressed
              if ( (keycombo[0] & FL_CTRL) || (keycombo[0] == FL_Control_L || keycombo[0] == FL_Control_R)) {

                  // Scale Image
                  img_scale();

                  // scale regions
                  Resizeable* box;

                  signed int img_center_x = shp_image->x() + (shp_image->w() / 2);
                  signed int img_center_y = shp_image->y() + (shp_image->h() / 2);
                  signed int rsize_w;
                  signed int rsize_h;
                  unsigned num_childs = shp_image->children();
                  for (unsigned int i = 0; i < num_childs; i++) {
                      box = (Resizeable*)shp_image->child(i);

                      // (old_coordinate_x - focus_point_around_which_scale_is_done_x)*scale_factor + focus_point_around_which_scale_is_done_x = new_coordinate_
                      rsize_w  = (signed int)((float)settings->width(i) * imgzoom);
                      rsize_h = (signed int)((float)settings->height(i) * imgzoom);

                      box->position(
                          (signed int)((float)((settings->posx(i) - (settings->width(i) * 0.5f)) * imgzoom) + img_center_x),
                              (signed int)((float)((settings->posy(i) - (settings->height(i) * 0.5f)) * imgzoom) + img_center_y)
                          );


                      if (rsize_w > 0 && rsize_h > 1 && rsize_w >= imgmin_limit && rsize_h >= imgmin_limit && rsize_w <= imgmax_limit && rsize_h <= imgmax_limit) {
                          box->size(
                              rsize_w,
                              rsize_h
                              );

                          }


                      box->redraw();



                      }

                  redraw_ui();

                  }
              else {
                  // Save Text
                  save_txt();

                  // Add any Tags and Regions to the image database
                  /*
                  TO DO HERE WRITE FUNCTION TO MERGE DATABASE
                  */

                  // Load next Image in the directory from the files array
                  if (Fl::event_dy() > 0) {sel_file++;} else {sel_file--;}
                  if (sel_file < 0) {sel_file = 0;} else if ((unsigned)(sel_file + 1) > num_files) {sel_file = num_files - 1;}
                  settings->selected = sel_file;
                  load_image();
                  }
              return 1;
              }
          break;
          }
      case FL_SHORTCUT: {
          if (debug) { std::cout << "IMAGE MODIFIER\n";}
          keycombo[1] = keycombo[0];
          keycombo[0] = Fl::event_key();



          break;
          }

      // for debugging
      default: {
          //    if (mousecur != Fl_Cursor::FL_CURSOR_DEFAULT) {
          //        mousecur = Fl_Cursor::FL_CURSOR_DEFAULT;
          //        win_main->cursor(mousecur);
          //        win_main->redraw();
          //        }
          //    keycombo[1] = keycombo[0];
          //    keycombo[0] = 0;
          //    printf("[%2d] MISSED = %2d = %s\n", 0, e, fl_eventnames[e]);
          //    fflush(stdout);
          }
      }
  return(Fl_Group::handle(e));
}

static void exitwindow() {
  save_txt();

  if (imgbuf != nullptr) {delete imgbuf;}
  if (imgtmp != nullptr) {delete imgtmp;}


  //if (cat_xpm != nullptr) {delete cat_xpm;}
  //settings->unload();
  settings->close();

  exit(0);
}

/**
 suppose to handle key press inputs globally
 however does not pick up all the inputs?
 to get more control you have to overload
 the event handler in each widget class.
 but seems I need to have first activated
 this global handler first for that to work??
 not sure, don't care, heres a global handler
 that doesn't do much :/
*/
int keyhandler(int event) {
  // static int n = 0; n++; n %= 100; // used for debugging inputs

  switch (event) {

      // ignore
      case FL_MOVE: {break;}
      case FL_NO_EVENT: {break;}

      // Need to respond to FOCUS events in order to handle keyboard
      case FL_FOCUS: {return 1;} // RESPOND TO FOCUS/UNFOCUS
      case FL_UNFOCUS: {         // RESPOND TO FOCUS/UNFOCUS
          // interupt registered key combos... not sure I need this?
          if (debug) {std::cout << "WINDOW FRAME EXIT\n";}
          keycombo[0] =  keycombo[1] = 0;
          return 1;
          }

      // get positions of the mouse
      case FL_DRAG: {
          if (keycombo[0] == FL_LEFT_MOUSE && keycombo[1] != 17891328) {
              img_move();
              }
          break;
          }

      // use for debugging inputs
      //default: {
      //    printf("[%2d] MISSED = %2d = %s\n", 0, event, fl_eventnames[event]);
      //    fflush(stdout);
      //    }
      }

  return event;
}
// >>>>>>>>>>>       CALL BACKS       <<<<<<<<<<<<

static void split_images_into_subfolders(Fl_Widget* o, void* userdata) {
  if (!os::doesFileExistW(work_path)) {
      fl_choice("Path Not Set", "OK", 0, 0);
      return;
      }
  const char *sp = static_cast<const char*>(userdata);
  const char val = *sp;
  bool good = false;
  switch (val) {
      case '1': {
          // move images and text based on a tag within the text
          const char* input = fl_input("Type Tags to Search and use to Move");
          if (input != nullptr) {
              moveTagsFromPath(work_path, (std::string)input);
              good = true;
              }
          break;
          }
      case '2': {
          // move images and text based on the images dimension
          binMaps(work_path);
          good = true;
          break;
          }
      }
  // Open Path
  if (good) {
      fl_choice("Files Moved, Check Folder", "OK", 0, 0);
      os::openPathW(work_path);
      };

  // clean up pointer?
  //delete sp;
}

static void modify_tags_in_path(Fl_Widget* o, void* userdata) {
  if (!os::doesFileExistW(work_path)) {
      fl_choice("Path Not Set", "OK", 0, 0);
      return;
      }
  const char *sp = static_cast<const char*>(userdata);
  const char val = *sp;
  std::string outmsg = "";
  switch (val) {
      case '0': { // collect all tags from folder and print to file
          getTagsFromPathOfTxt(work_path);
          break;
          }
      case '1': { // add a tag to all text files in path
          const char* input = fl_input("Type Tags to merge into text files");
          if (input != nullptr) {
              addTagsToPath(work_path, (std::string)input);
              outmsg = "Tags Merged, Check Folder";
              }
          break;
          }
      case '2': { // delete a tag to all text files in path
          const char* input = fl_input("Type Tags to remove from text files");
          if (input != nullptr) {
              removeTagsFromPath(work_path, (std::string)input, false);
              outmsg = "Tags Deleted, Check Folder";
              }
          break;
          }
      case '3': { // replace a tag to all text files in path
          const char* input_find = fl_input("Type Tags to search for");
          std::string findStr = input_find;
          if (input_find != nullptr) {
              const char* input_replacement = fl_input("Type text to replace tags with");
              std::string newStr = input_replacement;
              if (input_replacement != nullptr) {
                  ReplaceTagsInPath(work_path, findStr, newStr);
                  outmsg = "Tags Replaced, Check Folder";
                  }
              }
          break;
          }
      case '4': { // overwrite text files entirely
          const char* input = fl_input("Type Tags to create new tag files with");
          if (input != nullptr) {
              overwriteTagsInPath(work_path, (std::string)input);
              outmsg = "Tags Overwritten, Check Folder";
              }
          break;
          }
      }

  // Open Path
  if (outmsg != "") {
      fl_choice(outmsg.c_str(), "OK", 0, 0);
      os::openPathW(work_path);
      };

  // clean up pointer?
  //delete sp;
}

static void img_fullsize(Fl_Widget* o, void* userdata) {
  imgzoom = 1.0f;
  img_rescale();
  redraw_ui();
}

static void img_bigger(Fl_Widget* o, void* userdata) {
  imgzoom *= 1.1f;
  if (imgzoom < 0.1f) {imgzoom = 0.1f;}
  else if (imgzoom > 2.0f) {imgzoom = 2.0f;}

  img_rescale();
  redraw_ui();
}

static void img_smaller(Fl_Widget* o, void* userdata) {
  imgzoom *= 0.9f;
  if (imgzoom < 0.1f) {imgzoom = 0.1f;}
  else if (imgzoom > 2.0f) {imgzoom = 2.0f;}

  img_rescale();
  redraw_ui();
}

static void img_lockzoom(Fl_Widget* o, void* userdata) {
  imgfit = bit::flip(imgfit, 1);
}

static void toggle_imgfit(Fl_Widget* o, void* userdata) {
  const char *sp = static_cast<const char*>(userdata);
  const char val = *sp;
  switch (val) {
      case '2': {
          imgfit = bit::flip(imgfit, 2);
          Fl_Multi_Label *ml = (Fl_Multi_Label*)chk_shrink->label();
          //std::string oldlabel = ml->labelb;
          if (bit::get(imgfit, 2)) {chk_shrink->image(icon_checked());}
          else                     {chk_shrink->image(icon_unchecked());}
          //ml->typea  = _FL_IMAGE_LABEL;
          if (bit::get(imgfit, 2)) {ml->labela = (const char*)icon_checked();}
          else                     {ml->labela = (const char*)icon_unchecked();}
          //ml->typeb  = FL_NORMAL_LABEL;
          //ml->labelb = (char*)oldlabel.c_str();
          //ml->label(chk_shrink);
          chk_shrink->label(_FL_MULTI_LABEL , (const char *)ml);
          //ml->label(chk_shrink);
          break;
          }
      case '3': {
          imgfit = bit::flip(imgfit, 3);
          Fl_Multi_Label *ml = (Fl_Multi_Label*)chk_grow->label();
          //std::string oldlabel = ml->labelb;
          if (bit::get(imgfit, 3)) {chk_grow->image(icon_checked());}
          else                     {chk_grow->image(icon_unchecked());}
          //ml->typea  = _FL_IMAGE_LABEL;
          if (bit::get(imgfit, 3)) {ml->labela = (const char*)icon_checked();}
          else                     {ml->labela = (const char*)icon_unchecked();}
          //ml->typeb  = FL_NORMAL_LABEL;
          //ml->labelb = (char*)oldlabel.c_str();
          //ml->label(chk_grow);
          chk_grow->label(_FL_MULTI_LABEL , (const char *)ml);
          //ml->label(chk_grow);
          break;
          }
      }
  img_resize();
  img_rescale();
  redraw_ui();
  delete sp;
}

static void mnu_set_path() {
  const char* input = fl_input("please type new path", unicode_to_utf8(work_path).c_str());
  if (input != nullptr) {
  	std::string tmp = std::string(input);
  	std::wstring new_path = utf8_2_unicode(tmp);
  	if (new_path.size() > 0) {

  		if (new_path.substr(new_path.size() - 1, 1) != L"\\" || new_path.substr(new_path.size() - 1, 1) != L"/") {
  			new_path += L"\\";
  			}
  		if (os::doesFileExistW(new_path)) {
  			work_path = new_path;
  			}
  		else {fl_choice("Failed to Set Path", "OK", 0, 0);}
  		}
  	}
}

static void mnu_delete_event() {
  // check that image selection from directory is valid
  if (!isSelectionValid()) {
  	std::cout << "error failed to delete, sel_file out of bounds [" << sel_file << ": " << filesW.size() << "]" << std::endl;
  	return;
  	}
  switch ( fl_choice("Permanently Delete File?", "OK", "Cancel", 0) ) {
  	case 0: {
  		if (num_files > 0) {
  			os::deleteFileW(filesW.at(sel_file));
  			filesW.erase(filesW.begin() + sel_file);
  			num_files--;
  			if (sel_file > 0) {sel_file--;} else if (num_files > 0) {sel_file = num_files - 1;}
  			settings->selected = sel_file;
  			load_image();
  			redraw_ui();
  			}
  		break;
  		}
  	case 1: {break;} // no
  	}
}

static void mnu_rename_event() {
  // check that image selection from directory is valid
  if (!isSelectionValid()) {
  	std::cout << "error failed to rename, sel_file out of bounts [" << sel_file << ": " << filesW.size() << "]" << std::endl;
  	return;
  	}

  // get name of current file and convert it from wide char to utf8
  std::string str = unicode_to_utf8(getFilename::FromPathW(filesW.at(sel_file)));
  std::wstring fext = toLowerW(getFilename::TypeW(filesW.at(sel_file)));

  // prompt user for input
  const char* input = fl_input("Rename File", str.c_str());

  // check input was given
  if (input != nullptr) {

  	// convert utf8 input back to wide char
  	str = input;
  	std::wstring wstr = utf8_2_unicode(str);

  	// add file extension if not already in new name
  	std::wstring tmp = toLowerW(getFilename::TypeW(wstr));
  	if (fext != tmp) {wstr += fext;}

  	// rename file
  	tmp = getFilename::PathW(filesW.at(sel_file)) + wstr;
  	//std::wcout << L"NEW FILE: \t" << tmp << std::endl;
  	os::renameFileW(filesW.at(sel_file), tmp);
  	filesW.at(sel_file) = tmp;
  	str = unicode_to_utf8(wstr);
  	lb_file->value(str.c_str());
  	SetWindowTextW(xid, wstr.c_str());
  	}
}

static void mnu_autosavetxt_event() {
  write_txt = bit::flip(write_txt, 1);
  Fl_Multi_Label *ml = (Fl_Multi_Label*)mnu_autosavetxt->label();
  if (bit::get(write_txt, 1)) {mnu_autosavetxt->image(icon_checked());}
  else                        {mnu_autosavetxt->image(icon_unchecked());}
  if (bit::get(write_txt, 1)) {ml->labela = (const char*)icon_checked();}
  else                        {ml->labela = (const char*)icon_unchecked();}
  mnu_autosavetxt->label(_FL_MULTI_LABEL , (const char *)ml);
}

static void mnu_content_event() {
  fl_message(
  	"F1            \t: Help\n"
  	"F3            \t: Auto Shrink\n"
  	"F4            \t: Auto Enlarge\n"
  	"F2            \t: Rename Open File\n"
  	"Ctrl+D        \t: Delete Open File\n"
  	"Ctrl+G        \t: Go To Image Index\n"
  	"HOME          \t: Go To First Image\n"
  	"END           \t: Go To Last Image\n"
  	"Ctrl+O        \t: Open\n"
  	"Escape        \t: Close App\n"
  	"LMB+Drag      \t: Pan Image\n"
  	"RightClick    \t: Reset Position\n"
  	"Scroll        \t: Cycle Images\n"
  	"Alt +LMB      \t: Delete Region\n"
  	"DoubleClickLMB\t: Rename Region\n"
  	"Ctrl+LMB      \t: Add Region\n"
  	"Ctrl+Scroll   \t: Zoom in / Out\n"
  	"Ctrl+PageUp   \t: Zoom In\n"
  	"Ctrl+PageDown \t: Zoom Out\n"
  	"Ctrl+Home     \t: Reset Zoom\n"
  	"Ctrl+End      \t: Lock Zoom\n\n"
  	"* LMB = Left   Mouse Button\n"
  	"* MMB = Middle Mouse Button\n"
  	"* RMB = Right  Mouse Button"
  	);
}

static void mnu_about_event() {
  fl_message(
  	"Image Viewer (IMV)\n\n"
  	"Interface created using FLTK (https://www.fltk.org)\n"
  	"Opens BMP/JPG/PNG using the support in FLTK.\n\n"
  	"Top pane views images and the bottom pane allows\n"
  	"for text input to assist in stable diffusion tagging.\n\n"
  	"Text files are saved in the same path as the images\n"
  	"and is automatically saved when the app is closed\n"
  	"or another image is loaded.\n\n"
  	"Written by Corey Ngueyn (March 9 2023)"
  	);
}

static void mnu_goto_event() {
  // Check that file is loaded
  if (sel_file < 0 || imgbuf == nullptr || num_files < 1) {return; }

  // get current image index
  std::string str = to_string(sel_file + 1);

  // prompt user for input
  const char* input = fl_input("Jump to Image #", str.c_str());

  // check input was given
  if (input != nullptr) {

  	// convert intput into an int
  	unsigned int goto_index = convert_to<unsigned int>(std::string(input));

  	// Validate new Index
  	if (goto_index > filesW.size() || goto_index < 1) {return;}
  	sel_file = goto_index - 1;
  	settings->selected = sel_file;

  	// Load Image
  	load_image();
  	}
}

static void mnu_showregions_event() {
  unsigned int num_regions = shp_image->children();
  if (num_regions == 0) {return;}
  bool hide = !bit::get(visiblity, 1);
  visiblity = bit::set(visiblity, 1, hide);
  Fl_Multi_Label *ml = (Fl_Multi_Label*)mnu_showregions->label();
  visiblity = bit::set(visiblity, 1, hide);
  if (!hide) {
      mnu_showregions->image(icon_unchecked());
      ml->labela = (const char*)icon_unchecked();
      }
  else {
      mnu_showregions->image(icon_checked());
      ml->labela = (const char*)icon_checked();
      }
  mnu_showregions->label(_FL_MULTI_LABEL , (const char *)ml);
  for (unsigned int i = 0; i < num_regions; i++) {
      Resizeable* boxregion = (Resizeable*)shp_image->child(i);
      if (!hide) {
          boxregion->hide();
          }
      else {
          boxregion->show();
          }
      }
}

static void mnu_showeditor_event() {
  Fl_Multi_Label *ml = (Fl_Multi_Label*)mnu_showeditor->label();
  if (bit::get(visiblity, 2)) {
  	// Hide

  	// Change Icon in Menu
  	mnu_showeditor->image(icon_unchecked());
  	ml->labela = (const char*)icon_unchecked();

  	// resize the image and editor panels

  	//tile_info->position(0, 50, 15, 88);

  	// image pane
  	tile_view->size(tile_info->w(), lb_statusbar->y() - tile_view->y());
  	//tile_edit->resize(0,  lb_statusbar->y(), tile_view->w(), 0);
  	tile_edit->position(0, lb_statusbar->y());


  	//tile_edit->hide();

  	}
  else {
  	// SHOW

  	// Change Icon
  	mnu_showeditor->image(icon_checked());
  	ml->labela = (const char*)icon_checked();


  	// resize the image pane
  	//tile_info->position(0, 50, 15, 88);

  	tile_view->size(win_main->w(), (int)((double)win_main->h() * 0.71875));
  	tile_edit->resize(0, tile_view->y() + tile_view->h(), tile_view->w(), lb_statusbar->y() - (tile_view->y() + tile_view->h()));

  	//tile_edit->show();
  	}
  visiblity = bit::set(visiblity, 2, !bit::get(visiblity, 2));
  mnu_showeditor->label(_FL_MULTI_LABEL , (const char *)ml);
  redraw_ui();
}

static void mnu_showtags_event() {
  Fl_Multi_Label *ml = (Fl_Multi_Label*)mnu_showtags->label();
  if (bit::get(visiblity, 3)) {
  	mnu_showtags->image(icon_unchecked());
  	ml->labela = (const char*)icon_unchecked();
  	tag_sidebar_pack->hide();
  	visiblity = bit::set(visiblity, 3, false);
  	}
  else {
  	mnu_showtags->image(icon_checked());
  	ml->labela = (const char*)icon_checked();
  	tag_sidebar_pack->show();
  	tag_sidebar_pack->resize(0, 20, (unsigned int)((double)win_main->w() * 0.25), shp_image->h());
  	visiblity = bit::set(visiblity, 3, true);
  	}
  mnu_showtags->label(_FL_MULTI_LABEL , (const char *)ml);
}

static void mnu_goto_start_event() {
  if (!isSelectionValid() || filesW.size() <= 1) {return;}

  // Save Text
  save_txt();

  // Load next Image in the directory from the files array
  sel_file=0;
  settings->selected = sel_file;
  load_image();
}

static void mnu_goto_end_event() {
  if (!isSelectionValid() || sel_file + 1 >= (signed int)filesW.size() || filesW.size() <= 1) {return;}

  // Save Text
  save_txt();

  // Load next Image in the directory from the files array
  sel_file=filesW.size()-1;
  settings->selected = sel_file;
  load_image();
}

static void mnu_goto_next_event() {
  if (!isSelectionValid()) {return;}

  // Save Text
  save_txt();

  // Load next Image in the directory from the files array
  sel_file++;
  if (sel_file < 0) {sel_file = 0;} else if ((unsigned)(sel_file + 1) > num_files) {sel_file = num_files - 1;}
  settings->selected = sel_file;
  load_image();
}

static void mnu_goto_last_event() {
  if (!isSelectionValid()) {return;}

  // Save Text
  save_txt();

  // Load next Image in the directory from the files array
  sel_file--;
  if (sel_file < 0) {sel_file = 0;} else if ((unsigned)(sel_file + 1) > num_files) {sel_file = num_files - 1;}
  settings->selected = sel_file;
  load_image();
}

static void mnu_export_region_event() {
  std::wcout << L"work_path: \t" << work_path << std::endl;


  // check working directory is valid
  if (!os::doesFileExistW(work_path)) {
  	fl_message("invalid path set");
  	return;
  	}

  // collect csv files
  std::vector<std::wstring> files = os::getFilesW(work_path + L"*.csv");
  unsigned int num_files = files.size();
  std::cout << "num csv files: \t" << num_files << std::endl;
  // bail if no files
  if (num_files == 0)  {
  	fl_message("no csv files discovered");
  	return;
  	}

  // process each csv
  bytestream f;
  std::wstring imgfile;
  std::wstring newfile;
  std::wstring fname;
  std::vector<std::string> txt;
  std::string str;
  unsigned int num_rows;
  unsigned int num_cols;
  unsigned int name_col = 0;
  unsigned int posx_col = 1;
  unsigned int posy_col = 2;
  unsigned int dimx_col = 3;
  unsigned int dimy_col = 4;
  unsigned int row_start;
  unsigned int num_regions;
  bool hasHeader;
  std::string delimiter = ",";
  std::vector<std::string> header;
  std::vector<std::string> tmp;
  unsigned int x;
  std::string region_name;
  unsigned int type = 256;
  std::string ofile;
  Fl_Image* img = nullptr;
  unsigned char region_d;
  signed int region_x = 0, region_y = 0, region_w = 0, region_h = 0;
  bool imgpass;
  unsigned int c = 0;
  unsigned int buf_size;
  for (unsigned int r = 0; r < num_files; r++) {

  	// get base name
  	fname = getFilename::FileW(files.at(r));

  	// get image pair
  	imgfile = L"";
  	for (unsigned int k = 0; k < 4; k++) {

  		// make filepath to new folder
  		newfile = work_path + fname + knownTypes[k];

  		// skip if no file found
  		if (!os::doesFileExistW(newfile)) {continue;}

  		// collect image path
  		imgfile = newfile;
  		type = k;
  		break;
  		}

  	// skip if no image pair found
  	if (imgfile == L"") {continue;}

  	// skip if fail to open file
  	if (!f.openFileW(files.at(r))) {continue;}

  	// Load Image
  	img = nullptr;
  	imgpass = true;
  	ofile = unicode_to_utf8(imgfile);
  	switch (type) {
  		case 0: {
  			Fl_JPEG_Image* jpg = new Fl_JPEG_Image(ofile.c_str());
  			char* errMsg = nullptr;
  			size_t errMsgLen = 0;
  			switch ( jpg->fail() ) { // Check for Errors
  				case Fl_Image::ERR_NO_IMAGE:
  				case Fl_Image::ERR_FILE_ACCESS: {
  					strerror_s(errMsg, errMsgLen, errno);
  					fl_alert("%s: %s", ofile.c_str(), std::string(errMsg).c_str());
  					if (errMsg != nullptr) {delete errMsg;}
  					imgpass = false;
  					break;
  					}
  				case Fl_Image::ERR_FORMAT: {
  					fl_alert("%s: couldn't decode image", ofile.c_str());
  					imgpass = false;
  					break;
  					}
  				}
  			if (imgpass) {img = jpg->copy();}
  			delete jpg;
  			break;
  			}
  		case 1: {
  			Fl_JPEG_Image* jpg = new Fl_JPEG_Image(ofile.c_str());
  			char* errMsg = nullptr;
  			size_t errMsgLen = 0;
  			switch ( jpg->fail() ) { // Check for Errors
  				case Fl_Image::ERR_NO_IMAGE:
  				case Fl_Image::ERR_FILE_ACCESS: {
  					strerror_s(errMsg, errMsgLen, errno);
  					fl_alert("%s: %s", ofile.c_str(), std::string(errMsg).c_str());
  					if (errMsg != nullptr) {delete errMsg;}
  					imgpass = false;
  					break;
  					}
  				case Fl_Image::ERR_FORMAT: {
  					fl_alert("%s: couldn't decode image", ofile.c_str());
  					imgpass = false;
  					break;
  					}
  				}
  			if (imgpass) {img = jpg->copy();}
  			delete jpg;
  			break;
  			}
  		case 2: {
  			Fl_BMP_Image* bmp = new Fl_BMP_Image(ofile.c_str());
  			char* errMsg = nullptr;
  			size_t errMsgLen = 0;
  			switch ( bmp->fail() ) { // Check for Errors
  				case Fl_Image::ERR_NO_IMAGE:
  				case Fl_Image::ERR_FILE_ACCESS: {
  					strerror_s(errMsg, errMsgLen, errno);
  					fl_alert("%s: %s", ofile.c_str(), std::string(errMsg).c_str()); break;
  					if (errMsg != nullptr) { delete errMsg; }
  					imgpass = false;
  					break;
  					}
  				case Fl_Image::ERR_FORMAT: {
  					fl_alert("%s: couldn't decode image", ofile.c_str());
  					imgpass = false;
  					break;
  					}
  				}
  			if (imgpass) {img = bmp->copy();}
  			delete bmp;
  			break;
  			}
  		case 3: {
  			Fl_PNG_Image* png = new Fl_PNG_Image(ofile.c_str());
  			char* errMsg = nullptr;
  			size_t errMsgLen = 0;
  			switch ( png->fail() ) { // Check for Errors
  				case Fl_Image::ERR_NO_IMAGE:
  				case Fl_Image::ERR_FILE_ACCESS: {
  					strerror_s(errMsg, errMsgLen, errno);
  					fl_alert("%s: %s", ofile.c_str(), std::string(errMsg).c_str()); break;
  					if (errMsg != nullptr) { delete errMsg; }
  					imgpass = false;
  					break;
  					}
  				case Fl_Image::ERR_FORMAT: {
  					fl_alert("%s: couldn't decode image", ofile.c_str());
  					imgpass = false;
  					break;
  					}
  				}
  			if (imgpass) {img = png->copy();}
  			delete png;
  			break;
  			}

  		default: {
  			std::cout << "unsupported type\n";

  			}
  		}


  	if (img == nullptr) {
  		f.close();
  		continue;
  		}

  	// read the first buffer pointer to the RGB data, I didnt understand what the doc said about multiple image arrays, sooo
  	const char* buf = static_cast<const char*>( *img->data() );


  	// read each line of the text
  	txt.clear();
  	while (!f.eos()) {
  		str = trim(f.readline());
  		if (str.size() > 0) {
  			txt.push_back(str);
  			}
  		}

  	// check that txt isn't empty
  	num_rows = txt.size();
  	std::cout << "num_rows: \t" << num_rows << std::endl;
  	if (num_rows > 0 && txt.at(0).size() > 0) {

  		// check for header
  		header = split(txt.at(0), delimiter);

  		// if no header, check the file isn't using a different seperator character
  		num_cols = header.size();
  		std::cout << "num_cols: \t" << num_cols << std::endl;
  		if (num_cols == 0) {
  			delimiter = "\t";
  			header = split(txt.at(0), delimiter);
  			num_cols = header.size();
  			}

  		// correct for header if present

  		hasHeader = false;
  		for (unsigned int i = 0; i < num_cols; i++) {
  			// lowercase
  			header.at(i) = trim(tolower(header.at(i)), " ");

  			// search and collect index for each col
  			if      (header.at(i).find("name")   == 0) {name_col = i; hasHeader = true;}
  			else if (header.at(i).find("posx")   == 0) {posx_col = i; hasHeader = true;}
  			else if (header.at(i).find("posy")   == 0) {posy_col = i; hasHeader = true;}
  			else if (header.at(i).find("width")  == 0) {dimx_col = i; hasHeader = true;}
  			else if (header.at(i).find("height") == 0) {dimy_col = i; hasHeader = true;}
  			}

  		// set starting row
  		row_start = 0;
  		if (hasHeader) {row_start = 1;}

  		// check that theres rows to read
  		num_regions = num_rows - row_start;
  		std::cout << "num_regions: \t" << num_regions << std::endl;
  		if (num_regions > 0) {

  			// parse each line of the csv
  			tmp.clear();
  			region_w = 0;
  			region_h = 0;
  			for (unsigned int i = 0; i < num_regions; i++) {

  				// copy string
  				str = txt.at(row_start + i);


  				// parse out values
  				while (str.size() > 0) {


  					// check if there is a quoted value
  					if (str.substr(0, 1) == "\"") {
  						// trim out the first character
  						str = str.substr(1, str.size() - 1);

  						// check for trailing quote
  						x = str.find("\"");
  						if (x != std::string::npos && x > 0) {

  							// add value to the temp array
  							tmp.push_back(str.substr(0, x));

  							// remove from string
  							str.erase(0, x);
  							x = str.find(delimiter);
  							if (x != std::string::npos) {
  								str.erase(0, x + 1);
  								} else {str.erase(0, str.size());}
  							}
  						else {
  							x = str.find(delimiter);
  							if (x != std::string::npos) {
  								str.erase(0, x + 1);
  								} else {str.erase(0, str.size());}
  							}
  						}

  					// check if there is a delimiter character
  					else if ((x = str.find(delimiter)) != std::string::npos) {

  						if (x > 0) {
  							// add value to the temp array



  							tmp.push_back(str.substr(0, x));
  							str.erase(0, x + 1);

  							}
  						else {
  							// empty
  							tmp.push_back("");
  							str.erase(0, 1);

  							}

  						}

  					// just copy to the end of the string
  					else {

  						tmp.push_back(str.substr(0, str.size()));
  						str.erase(0, str.size());
  						str.clear();
  						}

  					// trim whitespace
  					str = trim(str);

  					}


  				// check that temp array is valid
  				x = tmp.size();
  				if (x > 0) {
  					// update region data
  					if (name_col < x) {region_name = tmp.at(name_col);}
  					if (posx_col < x) {region_x    = convert_to<signed int>(tmp.at(posx_col));}
  					if (posy_col < x) {region_y    = convert_to<signed int>(tmp.at(posy_col));}
  					if (dimx_col < x) {region_w    = convert_to<signed int>(tmp.at(dimx_col));}
  					if (dimy_col < x) {region_h    = convert_to<signed int>(tmp.at(dimy_col));}
  					}

  				// clear temp array
  				tmp.clear();



  				// modify the region position and dimension if out of bounds from the image
  				signed int dif;
  				if (region_x - (region_w / 2) < -(img->w() / 2)) {
  					dif = -(img->w() / 2) - region_x + (region_w / 2);
  					region_x += (signed int)(dif / 2.0);
  					region_w -= dif;
  					}
  				if (region_y - (region_h / 2) < -(img->h() / 2)) {
  					dif = -(img->h() / 2) - region_y + (region_h / 2);
  					region_y += (signed int)(dif / 2.0);
  					region_h -= dif;
  					}
  				if (region_x + (region_w / 2) > (img->w() / 2)) {
  					dif = (img->w() / 2) - region_x - (region_w / 2);
  					region_x += (signed int)(dif / 2.0);
  					region_w += dif;
  					}
  				if (region_y + (region_h / 2) > (img->h() / 2)) {
  					dif = (img->h() / 2) - region_y - (region_h / 2);
  					region_y += (signed int)(dif / 2.0);
  					region_h += dif;
  					}

  				// check region info is valid
  				std::cout << "region dim: \t" << region_w << " x " << region_h << std::endl;
  				if (img !=nullptr && region_w > 0 && region_h > 0) {

  					region_d = img->d();

  					// move box corrdinate from center to upper left
  					region_x -= region_w / 2;
  					region_y -= region_h / 2;
  					region_x += img->w() / 2;
  					region_y += img->h() / 2;


  					// calculate the buffer size
  					buf_size = region_w * region_h * region_d;

  					signed long read_pos = ((region_y * img->w()) + region_x) * region_d;
  					signed long lineskip = (img->w() - region_w) * region_d;
  					if (buf_size > 0 && read_pos >= 0 && lineskip >= 0) {

  						// create a buffer
  						char* rimg = new char[buf_size];

  						std::cout << "region_x: \t" << region_x << std::endl;
  						std::cout << "region_y: \t" << region_y << std::endl << std::endl;
  						std::cout << "region_w: \t" << region_w << std::endl;
  						std::cout << "region_h: \t" << region_h << std::endl;
  						std::cout << "region_d: \t" << (int)region_d << std::endl;

  						std::cout << "corrected dim: \t" << region_w << " x " << region_h << std::endl;
  						std::cout << "pos: \t" << read_pos << std::endl;

  						// copy pixels from main buffer to temp buffer
  						unsigned int v = 0;
  						unsigned int w = read_pos;
  							for (signed int x = 0; x < region_h; x++) {
  						for (int y = 0; y < region_w; y++) {
  								for (unsigned int c = 0; c < region_d; c++) {

  									rimg[v++] = buf[w++];


  									}
  								}
  							w = read_pos + (x * img->w() * region_d);
  							}


  						// i was confused about how I can save png's from in FLTK, so i just wrote my own exporter
  						bytestream p;
  						p.asPNG(rimg, region_w, region_h, (int)region_d, false, false);

  						// Save the PNG image to a file
  						std::wcout << L"save file: \t" << work_path << fname << L" region" << string_to_wstring(to_string(++c)) << L".png" << std::endl;
  						p.writeFileW(work_path + fname + string_to_wstring(region_name) + L" region" + string_to_wstring(to_string(++c)) + L".png");
  						p.close();

  						// delete buffer
  						delete[] rimg;


  						}



  					}



  				}
  			}
  		}

  	// close file
  	delete img;
  	f.close();

  	}
}

static void mnu_set_region_all() {

    // check working directory is valid
    // check working directory is valid
    if (!os::doesFileExistW(work_path)) {
        fl_message("invalid path set");
        return;
        }

    // collect files
    std::vector<std::wstring> files = os::getFilesW(work_path + L"*.*");
    unsigned int num_files = files.size();

    // process files
    std::wstring fext;
    bool bail = false;
    std::wstring csvfile;
    std::vector<region_data> regions_from_csv;
    unsigned int num_regions;
    bool addNewRegion;
    unsigned int w, h;
    for (unsigned int i = 0; i < num_files; i++) {

        // get file extension
        fext = toLowerW(getFilename::TypeW(files.at(i)));

        // check for valid image type
        bail = true;
        for (unsigned int k = 0; k < 4; k++) {
            if (fext == knownTypes[k]) {
                bail = false;
                break;
                }
            }

        // bail if type not supported
        if (bail) {continue;}

        // look for csv file
        csvfile = work_path + getFilename::FileW(files.at(i)) + L".csv";

        // bail if can't find the csv
        if (!os::doesFileExistW(csvfile)) {continue;}

        regions_from_csv = settings->readRegionCSV(csvfile);
        num_regions = regions_from_csv.size();
        if (num_regions > 0) {

            // look for a entry called region
            addNewRegion = true;
            for (unsigned int j = 0; j < num_regions; j++) {
                if (tolower(regions_from_csv.at(j).tag) == "region") {
                    addNewRegion = false;
                    }
                }

            if (addNewRegion) {

                // read dimensions from image file
                readDimFromImage(files.at(i), w, h);

                // check dimensions are valid
                if (w > 0 && h > 0) {

                    // square off the dimensions
                    if (w < h) {regions_from_csv.push_back(region_data(w, w, 0, 0, "region", false));}
                    else {regions_from_csv.push_back(region_data(h, h, 0, 0, "region", false));}

                    // write out the region file
                    settings->writeRegionCSV(csvfile, regions_from_csv);
                    }
                }
            }
        regions_from_csv.clear();
        }
    }

static void mnu_recent_file_event(Fl_Widget* o, void* userdata) {
  // lol i dont know what this is doing, i did some random stuff and it works oof
  unsigned int i = convert_to<unsigned int>(std::string(&*(const char *)(static_cast<const char*>(userdata))));

  if (settings != nullptr && settings->recents.size() > 0 && i < settings->recents.size() && settings->recents.at(i).size() > 0) {
      read_image(settings->recents.at(i));
      }
}

void btn_open_pressed() {
  Fl_Native_File_Chooser fnfc;
  fnfc.title("Pick a file");
  fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
  fnfc.filter("Supported Files\t*.bmp;*.jpg;*.png\nWindows Bitmap\t*.bmp\nJoint Photo Group\t*.jpg\nPortable Network Graphic\t*.png\n");
  fnfc.directory("/var/tmp");           // default directory to use

  // Show native chooser
  switch ( fnfc.show() ) {
      case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
      case  1: printf("CANCEL\n");                      break;  // CANCEL
      default: {read_image(fnfc.filename());}                   // FILE CHOSEN
      }
}

static void mnu_exit() {
  exitwindow();
}
// >>>>>>>>>>>     MAIN INTERFACE      <<<<<<<<<<<<

Fl_Double_Window *win_main=(Fl_Double_Window *)0;

Fl_Tile *tile_info=(Fl_Tile *)0;

Fl_GroupDC *tile_view=(Fl_GroupDC *)0;

Fl_GroupDC *shp_image=(Fl_GroupDC *)0;

Fl_Group *tile_edit=(Fl_Group *)0;

Fl_Text_EditorDC *edt_sdtags=(Fl_Text_EditorDC *)0;

Fl_ScrollDC *tag_sidebar=(Fl_ScrollDC *)0;

Fl_Pack *tag_sidebar_pack=(Fl_Pack *)0;

Fl_Group *lb_statusbar=(Fl_Group *)0;

Fl_Output *lb_page=(Fl_Output *)0;

Fl_Output *lb_file=(Fl_Output *)0;

Fl_Output *lb_fsize=(Fl_Output *)0;

Fl_Output *lb_info=(Fl_Output *)0;

Fl_Output *lb_zoom=(Fl_Output *)0;

Fl_Output *lb_loadtime=(Fl_Output *)0;

Fl_Menu_Bar *mnu_bar=(Fl_Menu_Bar *)0;

Fl_Menu_Item menu_mnu_bar[] = {
 {"&File", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open", 0x4006f,  (Fl_Callback*)btn_open_pressed, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Recent Files", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&1.) ", 0x30,  (Fl_Callback*)mnu_recent_file_event, (void*)("0"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&2.) ", 0x31,  (Fl_Callback*)mnu_recent_file_event, (void*)("1"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&3.) ", 0x32,  (Fl_Callback*)mnu_recent_file_event, (void*)("2"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&4.) ", 0x33,  (Fl_Callback*)mnu_recent_file_event, (void*)("3"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&5.) ", 0x34,  (Fl_Callback*)mnu_recent_file_event, (void*)("4"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&6.) ", 0x35,  (Fl_Callback*)mnu_recent_file_event, (void*)("5"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&7.) ", 0x36,  (Fl_Callback*)mnu_recent_file_event, (void*)("6"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&8.) ", 0x37,  (Fl_Callback*)mnu_recent_file_event, (void*)("7"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&9.) ", 0x38,  (Fl_Callback*)mnu_recent_file_event, (void*)("8"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&10.) ", 0x39,  (Fl_Callback*)mnu_recent_file_event, (void*)("9"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Exit", 0xff1b,  (Fl_Callback*)mnu_exit, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Edit", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Rename", 0xffbf,  (Fl_Callback*)mnu_rename_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Delete", 0x40064,  (Fl_Callback*)mnu_delete_event, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Auto Save Txt", 0,  (Fl_Callback*)mnu_autosavetxt_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&View", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Show &Regions", 0,  (Fl_Callback*)mnu_showregions_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Show &Editor", 0,  (Fl_Callback*)mnu_showeditor_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Show &Tags Pane", 0,  (Fl_Callback*)mnu_showtags_event, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&More", 0x4ff55,  (Fl_Callback*)img_bigger, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Less", 0x4ff56,  (Fl_Callback*)img_smaller, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Best Fit", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Actual Size", 0x4ff50,  (Fl_Callback*)img_fullsize, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Loc&k", 0x4ff57,  (Fl_Callback*)img_lockzoom, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Auto &Shrink to Fit", 0xffc0,  (Fl_Callback*)toggle_imgfit, (void*)("2"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Auto &Enlarge to Fit", 0xffc1,  (Fl_Callback*)toggle_imgfit, (void*)("3"), 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Go to #", 0x40067,  (Fl_Callback*)mnu_goto_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Next", 0x2e,  (Fl_Callback*)mnu_goto_next_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Previous", 0x2c,  (Fl_Callback*)mnu_goto_last_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&First", 0xff50,  (Fl_Callback*)mnu_goto_start_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Last", 0xff57,  (Fl_Callback*)mnu_goto_end_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Manage", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Set Path", 0,  (Fl_Callback*)mnu_set_path, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Batch Rename", 0,  (Fl_Callback*)batch_rename, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Move to Folder by &Tag", 0,  (Fl_Callback*)split_images_into_subfolders, (void*)("1"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Move to Folder by &Dimension", 0,  (Fl_Callback*)split_images_into_subfolders, (void*)("2"), 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Collect all Tags from Path", 0,  (Fl_Callback*)modify_tags_in_path, (void*)("0"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Add Tags in Path", 0,  (Fl_Callback*)modify_tags_in_path, (void*)("1"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Delete Tags in Path", 0,  (Fl_Callback*)modify_tags_in_path, (void*)("2"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Replace Tags in Path", 0,  (Fl_Callback*)modify_tags_in_path, (void*)("3"), 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Overwrite Tags in Path", 0,  (Fl_Callback*)modify_tags_in_path, (void*)("4"), 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Regions", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Set Square on all", 0,  (Fl_Callback*)mnu_set_region_all, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Export Regions", 0,  (Fl_Callback*)mnu_export_region_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&About", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Contents", 0xffbe,  (Fl_Callback*)mnu_content_event, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&About", 0,  (Fl_Callback*)mnu_about_event, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Double_Window* make_window() {
  init_database();
  { Fl_Double_Window* o = win_main = new Fl_Double_Window(640, 480, "IMV v0.1");
    win_main->color((Fl_Color)16);
    win_main->callback((Fl_Callback*)exitwindow);
    { tile_info = new Fl_Tile(-20, 20, 660, 443);
      tile_info->box(FL_FLAT_BOX);
      tile_info->color((Fl_Color)14);
      { tile_view = new Fl_GroupDC(0, 20, 640, 345);
        tile_view->box(FL_PLASTIC_UP_BOX);
        tile_view->color((Fl_Color)20);
        tile_view->selection_color(FL_BACKGROUND_COLOR);
        tile_view->labeltype(FL_NORMAL_LABEL);
        tile_view->labelfont(0);
        tile_view->labelsize(14);
        tile_view->labelcolor(FL_FOREGROUND_COLOR);
        tile_view->align(Fl_Align(FL_ALIGN_TOP));
        tile_view->when(FL_WHEN_RELEASE);
        { shp_image = new Fl_GroupDC(0, 20, 640, 345);
          shp_image->box(FL_NO_BOX);
          shp_image->color((Fl_Color)48);
          shp_image->selection_color(FL_BACKGROUND_COLOR);
          shp_image->labeltype(FL_NORMAL_LABEL);
          shp_image->labelfont(0);
          shp_image->labelsize(14);
          shp_image->labelcolor(FL_FOREGROUND_COLOR);
          shp_image->align(Fl_Align(FL_ALIGN_CENTER));
          shp_image->when(FL_WHEN_RELEASE);
        } // Fl_GroupDC* shp_image
        tile_view->resizable((Fl_Widget*)0); // no resizing
        tile_view->end();
      } // Fl_GroupDC* tile_view
      { tile_edit = new Fl_Group(0, 365, 640, 98);
        tile_edit->box(FL_GTK_UP_BOX);
        tile_edit->color(FL_DARK1);
        { Fl_Text_EditorDC* o = edt_sdtags = new Fl_Text_EditorDC(0, 365, 640, 98);
          edt_sdtags->box(FL_ENGRAVED_BOX);
          edt_sdtags->color((Fl_Color)48);
          edt_sdtags->selection_color(FL_SELECTION_COLOR);
          edt_sdtags->labeltype(FL_NORMAL_LABEL);
          edt_sdtags->labelfont(0);
          edt_sdtags->labelsize(14);
          edt_sdtags->labelcolor(FL_FOREGROUND_COLOR);
          edt_sdtags->align(Fl_Align(FL_ALIGN_TOP));
          edt_sdtags->when(FL_WHEN_RELEASE);
          textbuf = new Fl_Text_Buffer;
          o->buffer(textbuf); o->textsize(edt_font_size);
          o->show_insert_position();
          o->wrap_mode(Fl_Wrap::WRAP_AT_BOUNDS, 0);
        } // Fl_Text_EditorDC* edt_sdtags
        tile_edit->end();
      } // Fl_Group* tile_edit
      { tag_sidebar = new Fl_ScrollDC(0, 20, 160, 345);
        tag_sidebar->box(FL_NO_BOX);
        tag_sidebar->color((Fl_Color)12);
        tag_sidebar->selection_color(FL_BACKGROUND_COLOR);
        tag_sidebar->labeltype(FL_NORMAL_LABEL);
        tag_sidebar->labelfont(0);
        tag_sidebar->labelsize(14);
        tag_sidebar->labelcolor(FL_FOREGROUND_COLOR);
        tag_sidebar->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        tag_sidebar->when(FL_WHEN_RELEASE);
        { tag_sidebar_pack = new Fl_Pack(0, 20, 160, 345);
          tag_sidebar_pack->end();
        } // Fl_Pack* tag_sidebar_pack
        tag_sidebar->type(Fl_Scroll::VERTICAL); // disable scrollbars
        tag_sidebar->scrollbar_size( -1 ); // hide the scroll bars
        tag_sidebar->scrollbar.box(FL_NO_BOX); tag_sidebar->hscrollbar.box(FL_NO_BOX); tag_sidebar->box(FL_NO_BOX);
        tag_sidebar->scrollbar.align(4); // hide scroll bar to the left
        tag_sidebar->end();
      } // Fl_ScrollDC* tag_sidebar
      tile_info->end();
      Fl_Group::current()->resizable(tile_info);
    } // Fl_Tile* tile_info
    { lb_statusbar = new Fl_Group(0, 460, 640, 25);
      { lb_page = new Fl_Output(0, 462, 85, 18);
        lb_page->box(FL_EMBOSSED_BOX);
        lb_page->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Output* lb_page
      { lb_file = new Fl_Output(85, 462, 175, 18);
        lb_file->box(FL_EMBOSSED_BOX);
        lb_file->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Output* lb_file
      { lb_fsize = new Fl_Output(260, 462, 75, 18);
        lb_fsize->box(FL_EMBOSSED_BOX);
        lb_fsize->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Output* lb_fsize
      { lb_info = new Fl_Output(335, 462, 150, 18);
        lb_info->box(FL_EMBOSSED_BOX);
        lb_info->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Output* lb_info
      { lb_zoom = new Fl_Output(485, 462, 40, 18);
        lb_zoom->box(FL_EMBOSSED_BOX);
        lb_zoom->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Output* lb_zoom
      { lb_loadtime = new Fl_Output(525, 462, 115, 18);
        lb_loadtime->box(FL_EMBOSSED_BOX);
        lb_loadtime->align(Fl_Align(FL_ALIGN_TOP));
      } // Fl_Output* lb_loadtime
      lb_statusbar->end();
    } // Fl_Group* lb_statusbar
    { mnu_bar = new Fl_Menu_Bar(0, 0, 640, 20, "Recent Files");
      { Fl_Menu_Item* o = &menu_mnu_bar[1];
        add_multi_label(o, icon_open());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[14];
        add_multi_label(o, icon_exit());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[17];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[18];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[19];
        add_multi_label(o, icon_checked());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[22];
        add_multi_label(o, icon_checked());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[23];
        add_multi_label(o, icon_checked());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[24];
        add_multi_label(o, icon_checked());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[25];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[26];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[27];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[28];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[29];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[30];
        add_multi_label(o, icon_unchecked());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[31];
        add_multi_label(o, icon_unchecked());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[32];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[33];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[34];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[35];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[36];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[39];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[40];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[41];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[42];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[43];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[44];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[45];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[46];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[47];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[50];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[51];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[54];
        add_multi_label(o, icon_dummy());
      }
      { Fl_Menu_Item* o = &menu_mnu_bar[55];
        add_multi_label(o, icon_dummy());
      }
      mnu_bar->menu(menu_mnu_bar);
    } // Fl_Menu_Bar* mnu_bar
    o->icon((char*)LoadIcon(fl_display, MAKEINTRESOURCE(IDI_ICON)));
    Fl::scheme("gtk+");
    o->show();
    get_init_theme(fl_xid(o)); toggle_theme();
    win_main->size_range(640, 480);
    win_main->end();
  } // Fl_Double_Window* win_main
  return win_main;
}
